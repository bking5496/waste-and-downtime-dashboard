{"version":3,"file":"static/js/283.52c938bb.chunk.js","mappings":"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","sources":["types.ts","lib/storage.ts"],"sourcesContent":["export interface WasteEntry {\r\n  id: string;\r\n  waste: number;\r\n  wasteType: string;\r\n  timestamp: Date;\r\n}\r\n\r\nexport interface DowntimeEntry {\r\n  id: string;\r\n  downtime: number;\r\n  downtimeReason: string;\r\n  notes?: string;\r\n  timestamp: Date;\r\n}\r\n\r\n// Production timer state for tracking run time and pauses\r\nexport interface ProductionState {\r\n  isRunning: boolean;\r\n  startTime: Date | null;       // When production started\r\n  pausedAt: Date | null;        // When current pause began\r\n  totalRunTimeMs: number;       // Accumulated run time in milliseconds\r\n  lastResumedAt: Date | null;   // When last resumed from pause\r\n}\r\n\r\nexport interface SpeedEntry {\r\n  id: string;\r\n  speed: number;\r\n  timestamp: Date;\r\n}\r\n\r\nexport interface SachetMassEntry {\r\n  id: string;\r\n  mass: number; // in grams\r\n  timestamp: Date;\r\n  ignored?: boolean; // Can be set to ignore but not deleted\r\n}\r\n\r\n// Loose cases entry - for cases not part of a full pallet\r\nexport interface LooseCasesEntry {\r\n  id: string;\r\n  batchNumber: string; // 5-digit batch number\r\n  cases: number; // number of loose cases\r\n  timestamp: Date;\r\n  ignored?: boolean;\r\n}\r\n\r\n// Pallet Scan entry - QR code is 13 digits: BBBBBPPPPCCCC\r\n// B = batch number (5 digits), P = pallet number (4 digits), C = cases count (4 digits)\r\nexport interface PalletScanEntry {\r\n  id: string;\r\n  qrCode: string; // Full 13-digit QR code\r\n  batchNumber: string; // Extracted: first 5 digits\r\n  palletNumber: string; // Extracted: digits 6-9 (4 digits)\r\n  casesCount: number; // Extracted: last 4 digits\r\n  timestamp: Date;\r\n  ignored?: boolean;\r\n}\r\n\r\n// Legacy CasesPerHourEntry - kept for backwards compatibility\r\nexport interface CasesPerHourEntry {\r\n  id: string;\r\n  cases: number;\r\n  hour: number;\r\n  timestamp: Date;\r\n  ignored?: boolean;\r\n}\r\n\r\nexport interface ShiftData {\r\n  id: string;\r\n  operatorName: string;\r\n  machine: string;\r\n  subMachine?: string; // For machines that are groups (e.g., \"Universal 2 - Machine 1\")\r\n  orderNumber: string;\r\n  product: string;\r\n  batchNumber: string;\r\n  shift: string;\r\n  date: string;\r\n  wasteEntries: WasteEntry[];\r\n  downtimeEntries: DowntimeEntry[];\r\n  speedEntries?: SpeedEntry[];\r\n  sachetMassEntries?: SachetMassEntry[];\r\n  casesPerHourEntries?: CasesPerHourEntry[]; // Legacy - kept for backwards compatibility\r\n  looseCasesEntries?: LooseCasesEntry[]; // New: loose cases with batch number\r\n  palletScanEntries?: PalletScanEntry[];\r\n  submittedAt: Date;\r\n  totalWaste: number;\r\n  totalDowntime: number;\r\n}\r\n\r\nexport interface ShiftSession {\r\n  machineName: string;\r\n  operatorName: string;\r\n  orderNumber: string;\r\n  product: string;\r\n  batchNumber: string;\r\n  shift: string;\r\n  date: string;\r\n  locked: boolean; // Once set, these values are locked for the shift\r\n  // Entry data persisted with session\r\n  wasteEntries?: WasteEntry[];\r\n  downtimeEntries?: DowntimeEntry[];\r\n  speedEntries?: SpeedEntry[];\r\n  sachetMassEntries?: SachetMassEntry[];\r\n  casesPerHourEntries?: CasesPerHourEntry[]; // Legacy\r\n  looseCasesEntries?: LooseCasesEntry[]; // New\r\n  palletScanEntries?: PalletScanEntry[];\r\n}\r\n\r\nexport interface Machine {\r\n  id: string;\r\n  name: string;\r\n  status: 'running' | 'idle' | 'maintenance';\r\n  currentOperator?: string;\r\n  currentOrder?: string;\r\n  currentShift?: string;\r\n  lastSubmission?: string;\r\n  todayWaste?: number;\r\n  todayDowntime?: number;\r\n  subMachineCount?: number; // Number of sub-machines (e.g., 4 for \"Universal 2\")\r\n}\r\n\r\n// ==============================================\r\n// DEFAULT DATA\r\n// ==============================================\r\n\r\nexport const OPERATORS: string[] = [];\r\nexport const MACHINES: Machine[] = [];\r\n\r\n// Waste Types - common manufacturing waste categories\r\nexport const WASTE_TYPES: string[] = [\r\n  'Start-up Waste',\r\n  'Changeover Waste',\r\n  'Defective Product',\r\n  'Material Spillage',\r\n];\r\n\r\n// Downtime Reasons - categorized by planned vs unplanned\r\nexport const PLANNED_DOWNTIME_REASONS: string[] = [\r\n  'Scheduled Maintenance',\r\n  'Changeover',\r\n];\r\n\r\nexport const UNPLANNED_DOWNTIME_REASONS: string[] = [\r\n  'Machine Breakdown',\r\n  'Material Shortage',\r\n];\r\n\r\n// Combined downtime reasons for selection\r\nexport const DOWNTIME_REASONS: string[] = [\r\n  'Machine Breakdown',\r\n  'Scheduled Maintenance',\r\n  'Changeover',\r\n  'Material Shortage',\r\n];\r\n\r\nexport const ORDER_NUMBERS: string[] = [];\r\nexport const PRODUCTS: string[] = [];\r\nexport const BATCH_NUMBERS: string[] = [];\r\n\r\n","import { ShiftData, Machine, MACHINES } from '../types';\r\nimport {\r\n  fetchMachines,\r\n  upsertMachine,\r\n  removeMachine,\r\n  syncMachinesToSupabase,\r\n  subscribeMachineChanges,\r\n  MachineRecord,\r\n  submitShiftData,\r\n  isSupabaseConfigured\r\n} from './supabase';\r\n\r\nconst STORAGE_KEY = 'waste_downtime_history';\r\nconst MACHINES_KEY = 'machines_data';\r\nconst MACHINES_SYNC_KEY = 'machines_last_sync';\r\nconst FAILED_SUBMISSIONS_KEY = 'failed_submissions_queue';\r\nconst HISTORY_MAX_DAYS = 90; // Keep history for 90 days\r\nconst HISTORY_MAX_ENTRIES = 1000; // Maximum entries to keep\r\n\r\n// ==========================================\r\n// FAILED SUBMISSIONS RETRY QUEUE\r\n// ==========================================\r\n\r\ninterface FailedSubmission {\r\n  id: string;\r\n  timestamp: string;\r\n  retryCount: number;\r\n  maxRetries: number;\r\n  data: {\r\n    shiftData: any;\r\n    wasteEntries: any[];\r\n    downtimeEntries: any[];\r\n    speedEntries?: any[];\r\n    sachetMassEntries?: any[];\r\n    looseCasesEntries?: any[];\r\n    palletScanEntries?: any[];\r\n  };\r\n  error: string;\r\n}\r\n\r\n// Get failed submissions queue\r\nexport const getFailedSubmissions = (): FailedSubmission[] => {\r\n  const stored = localStorage.getItem(FAILED_SUBMISSIONS_KEY);\r\n  if (!stored) return [];\r\n  try {\r\n    return JSON.parse(stored);\r\n  } catch {\r\n    return [];\r\n  }\r\n};\r\n\r\n// Add a failed submission to the retry queue\r\nexport const addFailedSubmission = (\r\n  data: FailedSubmission['data'],\r\n  error: string\r\n): void => {\r\n  const queue = getFailedSubmissions();\r\n  const newEntry: FailedSubmission = {\r\n    id: `failed_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n    timestamp: new Date().toISOString(),\r\n    retryCount: 0,\r\n    maxRetries: 3,\r\n    data,\r\n    error,\r\n  };\r\n  queue.push(newEntry);\r\n  localStorage.setItem(FAILED_SUBMISSIONS_KEY, JSON.stringify(queue));\r\n};\r\n\r\n// Remove a submission from the failed queue\r\nexport const removeFailedSubmission = (id: string): void => {\r\n  const queue = getFailedSubmissions();\r\n  const filtered = queue.filter(s => s.id !== id);\r\n  localStorage.setItem(FAILED_SUBMISSIONS_KEY, JSON.stringify(filtered));\r\n};\r\n\r\n// Retry all failed submissions\r\nexport const retryFailedSubmissions = async (): Promise<{\r\n  succeeded: number;\r\n  failed: number;\r\n  remaining: number;\r\n}> => {\r\n  if (!isSupabaseConfigured) {\r\n    return { succeeded: 0, failed: 0, remaining: getFailedSubmissions().length };\r\n  }\r\n\r\n  const queue = getFailedSubmissions();\r\n  let succeeded = 0;\r\n  let failed = 0;\r\n\r\n  for (const submission of queue) {\r\n    if (submission.retryCount >= submission.maxRetries) {\r\n      // Max retries reached, keep in queue but don't retry\r\n      failed++;\r\n      continue;\r\n    }\r\n\r\n    try {\r\n      await submitShiftData(\r\n        submission.data.shiftData,\r\n        submission.data.wasteEntries,\r\n        submission.data.downtimeEntries,\r\n        submission.data.speedEntries,\r\n        submission.data.sachetMassEntries,\r\n        submission.data.looseCasesEntries,\r\n        submission.data.palletScanEntries\r\n      );\r\n      removeFailedSubmission(submission.id);\r\n      succeeded++;\r\n    } catch (e) {\r\n      // Update retry count\r\n      const updatedQueue = getFailedSubmissions().map(s =>\r\n        s.id === submission.id\r\n          ? { ...s, retryCount: s.retryCount + 1, error: String(e) }\r\n          : s\r\n      );\r\n      localStorage.setItem(FAILED_SUBMISSIONS_KEY, JSON.stringify(updatedQueue));\r\n      failed++;\r\n    }\r\n  }\r\n\r\n  return {\r\n    succeeded,\r\n    failed,\r\n    remaining: getFailedSubmissions().length,\r\n  };\r\n};\r\n\r\n// Clear all failed submissions (manual clear)\r\nexport const clearFailedSubmissions = (): void => {\r\n  localStorage.removeItem(FAILED_SUBMISSIONS_KEY);\r\n};\r\n\r\n// ==========================================\r\n// LOCALSTORAGE CLEANUP\r\n// ==========================================\r\n\r\n// Clean up old history entries\r\nexport const cleanupOldHistory = (): { removed: number; remaining: number } => {\r\n  const history = getShiftHistory();\r\n  const now = new Date();\r\n  const cutoffDate = new Date(now.getTime() - HISTORY_MAX_DAYS * 24 * 60 * 60 * 1000);\r\n\r\n  // Filter out entries older than cutoff date\r\n  let cleaned = history.filter(item => {\r\n    const itemDate = new Date(item.date);\r\n    return itemDate >= cutoffDate;\r\n  });\r\n\r\n  // Also limit to max entries (keep most recent)\r\n  if (cleaned.length > HISTORY_MAX_ENTRIES) {\r\n    cleaned = cleaned.slice(0, HISTORY_MAX_ENTRIES);\r\n  }\r\n\r\n  const removed = history.length - cleaned.length;\r\n\r\n  if (removed > 0) {\r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(cleaned));\r\n    console.log(`Cleaned up ${removed} old history entries`);\r\n  }\r\n\r\n  return { removed, remaining: cleaned.length };\r\n};\r\n\r\n// Get localStorage usage stats\r\nexport const getStorageStats = (): {\r\n  historyCount: number;\r\n  failedCount: number;\r\n  totalSizeKB: number;\r\n  oldestEntry: string | null;\r\n} => {\r\n  const history = getShiftHistory();\r\n  const failed = getFailedSubmissions();\r\n\r\n  // Estimate total localStorage size\r\n  let totalSize = 0;\r\n  for (let i = 0; i < localStorage.length; i++) {\r\n    const key = localStorage.key(i);\r\n    if (key) {\r\n      const value = localStorage.getItem(key) || '';\r\n      totalSize += key.length + value.length;\r\n    }\r\n  }\r\n\r\n  const oldestEntry = history.length > 0\r\n    ? history[history.length - 1].date\r\n    : null;\r\n\r\n  return {\r\n    historyCount: history.length,\r\n    failedCount: failed.length,\r\n    totalSizeKB: Math.round(totalSize / 1024),\r\n    oldestEntry,\r\n  };\r\n};\r\n\r\n// Run cleanup on app startup (debounced to run once per day)\r\nexport const maybeRunCleanup = (): void => {\r\n  const lastCleanupKey = 'last_storage_cleanup';\r\n  const lastCleanup = localStorage.getItem(lastCleanupKey);\r\n  const now = new Date();\r\n\r\n  if (lastCleanup) {\r\n    const lastDate = new Date(lastCleanup);\r\n    const hoursSinceCleanup = (now.getTime() - lastDate.getTime()) / (1000 * 60 * 60);\r\n    if (hoursSinceCleanup < 24) {\r\n      return; // Already cleaned up today\r\n    }\r\n  }\r\n\r\n  // Run cleanup\r\n  const result = cleanupOldHistory();\r\n  localStorage.setItem(lastCleanupKey, now.toISOString());\r\n\r\n  if (result.removed > 0) {\r\n    console.log(`Storage cleanup: removed ${result.removed} entries, ${result.remaining} remaining`);\r\n  }\r\n};\r\n\r\n// Flag to track if we're using Supabase\r\nlet useSupabase = true;\r\nlet machinesCache: Machine[] | null = null;\r\nlet machinesListeners: ((machines: Machine[]) => void)[] = [];\r\n\r\n// Convert Supabase record to local Machine type\r\nconst toLocalMachine = (record: MachineRecord): Machine => ({\r\n  id: record.id,\r\n  name: record.name,\r\n  status: record.status,\r\n  currentOperator: record.current_operator,\r\n  currentOrder: record.current_order,\r\n  currentShift: record.current_shift,\r\n  lastSubmission: record.last_submission,\r\n  todayWaste: record.today_waste,\r\n  todayDowntime: record.today_downtime,\r\n  subMachineCount: record.sub_machine_count,\r\n});\r\n\r\n// Convert local Machine to Supabase record\r\nconst toSupabaseRecord = (machine: Machine): MachineRecord => ({\r\n  id: machine.id,\r\n  name: machine.name,\r\n  status: machine.status,\r\n  current_operator: machine.currentOperator,\r\n  current_order: machine.currentOrder,\r\n  current_shift: machine.currentShift,\r\n  last_submission: machine.lastSubmission,\r\n  today_waste: machine.todayWaste,\r\n  today_downtime: machine.todayDowntime,\r\n  sub_machine_count: machine.subMachineCount,\r\n});\r\n\r\n// Initialize machines from Supabase\r\nexport const initializeMachines = async (): Promise<Machine[]> => {\r\n  try {\r\n    const records = await fetchMachines();\r\n\r\n    if (records.length > 0) {\r\n      machinesCache = records.map(toLocalMachine);\r\n      // Also save to localStorage as backup\r\n      localStorage.setItem(MACHINES_KEY, JSON.stringify(machinesCache));\r\n      localStorage.setItem(MACHINES_SYNC_KEY, new Date().toISOString());\r\n      return machinesCache;\r\n    } else {\r\n      // No machines in Supabase, sync default machines\r\n      console.log('No machines in Supabase, syncing defaults...');\r\n      const defaultMachines = MACHINES.map(toSupabaseRecord);\r\n      await syncMachinesToSupabase(defaultMachines);\r\n      machinesCache = MACHINES;\r\n      localStorage.setItem(MACHINES_KEY, JSON.stringify(MACHINES));\r\n      return MACHINES;\r\n    }\r\n  } catch (error) {\r\n    console.error('Failed to initialize from Supabase, using localStorage:', error);\r\n    useSupabase = false;\r\n    return getMachinesDataLocal();\r\n  }\r\n};\r\n\r\n// Subscribe to real-time machine updates - OPTIMIZED\r\nexport const subscribeToMachineUpdates = (callback: (machines: Machine[]) => void) => {\r\n  machinesListeners.push(callback);\r\n\r\n  // Provide current machines getter for optimized real-time updates\r\n  const getCurrentMachines = (): MachineRecord[] => {\r\n    const current = machinesCache || getMachinesDataLocal();\r\n    return current.map(toSupabaseRecord);\r\n  };\r\n\r\n  // Set up Supabase real-time subscription with optimized handler\r\n  const unsubscribe = subscribeMachineChanges(\r\n    (records) => {\r\n      machinesCache = records.map(toLocalMachine);\r\n      localStorage.setItem(MACHINES_KEY, JSON.stringify(machinesCache));\r\n\r\n      // Notify all listeners\r\n      machinesListeners.forEach(listener => listener(machinesCache!));\r\n    },\r\n    getCurrentMachines\r\n  );\r\n\r\n  // Return cleanup function\r\n  return () => {\r\n    machinesListeners = machinesListeners.filter(l => l !== callback);\r\n    if (machinesListeners.length === 0) {\r\n      unsubscribe();\r\n    }\r\n  };\r\n};\r\n\r\n// Get machines from localStorage (fallback)\r\nconst getMachinesDataLocal = (): Machine[] => {\r\n  const stored = localStorage.getItem(MACHINES_KEY);\r\n  if (!stored) {\r\n    localStorage.setItem(MACHINES_KEY, JSON.stringify(MACHINES));\r\n    return MACHINES;\r\n  }\r\n\r\n  try {\r\n    return JSON.parse(stored);\r\n  } catch {\r\n    return MACHINES;\r\n  }\r\n};\r\n\r\n// Save shift data to local storage\r\nexport const saveShiftData = (data: ShiftData): void => {\r\n  const existing = getShiftHistory();\r\n  existing.unshift(data);\r\n  localStorage.setItem(STORAGE_KEY, JSON.stringify(existing));\r\n\r\n  // Update machine data\r\n  updateMachineLastSubmission(data.machine, data.submittedAt.toISOString());\r\n};\r\n\r\n// Get all shift history\r\nexport const getShiftHistory = (): ShiftData[] => {\r\n  const stored = localStorage.getItem(STORAGE_KEY);\r\n  if (!stored) return [];\r\n\r\n  try {\r\n    const parsed = JSON.parse(stored);\r\n    return parsed.map((item: any) => ({\r\n      ...item,\r\n      submittedAt: new Date(item.submittedAt),\r\n      wasteEntries: item.wasteEntries.map((w: any) => ({\r\n        ...w,\r\n        timestamp: new Date(w.timestamp),\r\n      })),\r\n      downtimeEntries: item.downtimeEntries.map((d: any) => ({\r\n        ...d,\r\n        timestamp: new Date(d.timestamp),\r\n      })),\r\n    }));\r\n  } catch {\r\n    return [];\r\n  }\r\n};\r\n\r\n// Get shift history for a specific date range\r\nexport const getShiftHistoryByDateRange = (startDate: Date, endDate: Date): ShiftData[] => {\r\n  const history = getShiftHistory();\r\n  return history.filter(item => {\r\n    const itemDate = new Date(item.date);\r\n    return itemDate >= startDate && itemDate <= endDate;\r\n  });\r\n};\r\n\r\n// Get shift history for a specific machine\r\nexport const getShiftHistoryByMachine = (machineName: string): ShiftData[] => {\r\n  const history = getShiftHistory();\r\n  return history.filter(item => item.machine === machineName);\r\n};\r\n\r\n// Get today's statistics\r\nexport const getTodayStats = () => {\r\n  const today = new Date().toISOString().split('T')[0];\r\n  const history = getShiftHistory();\r\n  const todayData = history.filter(item => item.date === today);\r\n\r\n  const totalWaste = todayData.reduce((sum, item) => sum + item.totalWaste, 0);\r\n  const totalDowntime = todayData.reduce((sum, item) => sum + item.totalDowntime, 0);\r\n  const submissionCount = todayData.length;\r\n\r\n  return { totalWaste, totalDowntime, submissionCount };\r\n};\r\n\r\n// Update machine last submission\r\nexport const updateMachineLastSubmission = (machineName: string, timestamp: string): void => {\r\n  const machines = getMachinesData();\r\n  const machineIndex = machines.findIndex(m => m.name === machineName);\r\n  if (machineIndex !== -1) {\r\n    machines[machineIndex].lastSubmission = getTimeAgo(new Date(timestamp));\r\n  }\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(machines));\r\n};\r\n\r\n// Get machines data with local modifications\r\nexport const getMachinesData = (): Machine[] => {\r\n  // Return cache if available\r\n  if (machinesCache) {\r\n    return machinesCache;\r\n  }\r\n\r\n  // Otherwise return from localStorage\r\n  return getMachinesDataLocal();\r\n};\r\n\r\n// Update a single machine\r\nexport const updateMachine = async (machineId: string, updates: Partial<Machine>): Promise<void> => {\r\n  const machines = getMachinesData();\r\n  const index = machines.findIndex(m => m.id === machineId);\r\n  if (index !== -1) {\r\n    machines[index] = { ...machines[index], ...updates };\r\n    machinesCache = machines;\r\n    localStorage.setItem(MACHINES_KEY, JSON.stringify(machines));\r\n\r\n    // Sync to Supabase\r\n    if (useSupabase) {\r\n      try {\r\n        await upsertMachine(toSupabaseRecord(machines[index]));\r\n      } catch (error) {\r\n        console.error('Failed to sync machine update to Supabase:', error);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n// Add a new machine\r\nexport const addMachine = async (machine: Machine): Promise<void> => {\r\n  const machines = getMachinesData();\r\n  machines.push(machine);\r\n  machinesCache = machines;\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(machines));\r\n\r\n  // Sync to Supabase\r\n  if (useSupabase) {\r\n    try {\r\n      await upsertMachine(toSupabaseRecord(machine));\r\n    } catch (error) {\r\n      console.error('Failed to sync new machine to Supabase:', error);\r\n    }\r\n  }\r\n};\r\n\r\n// Delete a machine\r\nexport const deleteMachine = async (machineId: string): Promise<void> => {\r\n  const machines = getMachinesData();\r\n  const filtered = machines.filter(m => m.id !== machineId);\r\n  machinesCache = filtered;\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(filtered));\r\n\r\n  // Sync to Supabase\r\n  if (useSupabase) {\r\n    try {\r\n      await removeMachine(machineId);\r\n    } catch (error) {\r\n      console.error('Failed to delete machine from Supabase:', error);\r\n    }\r\n  }\r\n};\r\n\r\n// Reset machines to default\r\nexport const resetMachines = async (): Promise<void> => {\r\n  machinesCache = MACHINES;\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(MACHINES));\r\n\r\n  // Sync to Supabase\r\n  if (useSupabase) {\r\n    try {\r\n      await syncMachinesToSupabase(MACHINES.map(toSupabaseRecord));\r\n    } catch (error) {\r\n      console.error('Failed to reset machines in Supabase:', error);\r\n    }\r\n  }\r\n};\r\n\r\n// Helper function to format time ago\r\nexport const getTimeAgo = (date: Date): string => {\r\n  const now = new Date();\r\n  const diffMs = now.getTime() - date.getTime();\r\n  const diffMins = Math.floor(diffMs / 60000);\r\n  const diffHours = Math.floor(diffMins / 60);\r\n  const diffDays = Math.floor(diffHours / 24);\r\n\r\n  if (diffMins < 1) return 'Just now';\r\n  if (diffMins < 60) return `${diffMins} min ago`;\r\n  if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;\r\n  return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;\r\n};\r\n\r\n// Export data to CSV\r\nexport const exportToCSV = (data: ShiftData[], filename: string): void => {\r\n  const headers = [\r\n    'Date',\r\n    'Shift',\r\n    'Operator',\r\n    'Machine',\r\n    'Order Number',\r\n    'Product',\r\n    'Batch Number',\r\n    'Entry Type',\r\n    'Entry Timestamp',\r\n    'Waste Type',\r\n    'Waste (kg)',\r\n    'Downtime Reason',\r\n    'Downtime (min)',\r\n    'Speed (PPM)',\r\n    'Sachet Mass (g)',\r\n    'Loose Cases Batch',\r\n    'Loose Cases Count',\r\n    'Pallet QR Code',\r\n    'Pallet Batch',\r\n    'Pallet Number',\r\n    'Pallet Cases',\r\n    'Submitted At',\r\n  ];\r\n\r\n  const rows: string[][] = [];\r\n\r\n  data.forEach(item => {\r\n    const baseRow = [\r\n      item.date,\r\n      item.shift,\r\n      item.operatorName,\r\n      item.machine,\r\n      item.orderNumber,\r\n      item.product,\r\n      item.batchNumber,\r\n    ];\r\n    const submittedAt = item.submittedAt ? new Date(item.submittedAt).toLocaleString() : '';\r\n\r\n    // Add a row for each waste entry\r\n    if (item.wasteEntries && item.wasteEntries.length > 0) {\r\n      item.wasteEntries.forEach(w => {\r\n        const entryTime = w.timestamp ? new Date(w.timestamp).toLocaleString() : '';\r\n        rows.push([\r\n          ...baseRow,\r\n          'Waste',\r\n          entryTime,\r\n          w.wasteType,\r\n          w.waste.toFixed(2),\r\n          '', // downtime reason\r\n          '', // downtime min\r\n          '', // speed\r\n          '', // sachet mass\r\n          '', // loose cases batch\r\n          '', // loose cases count\r\n          '', // pallet qr\r\n          '', // pallet batch\r\n          '', // pallet number\r\n          '', // pallet cases\r\n          submittedAt,\r\n        ]);\r\n      });\r\n    }\r\n\r\n    // Add a row for each downtime entry\r\n    if (item.downtimeEntries && item.downtimeEntries.length > 0) {\r\n      item.downtimeEntries.forEach(d => {\r\n        const entryTime = d.timestamp ? new Date(d.timestamp).toLocaleString() : '';\r\n        rows.push([\r\n          ...baseRow,\r\n          'Downtime',\r\n          entryTime,\r\n          '', // waste type\r\n          '', // waste kg\r\n          d.downtimeReason,\r\n          d.downtime.toString(),\r\n          '', // speed\r\n          '', // sachet mass\r\n          '', // loose cases batch\r\n          '', // loose cases count\r\n          '', // pallet qr\r\n          '', // pallet batch\r\n          '', // pallet number\r\n          '', // pallet cases\r\n          submittedAt,\r\n        ]);\r\n      });\r\n    }\r\n\r\n    // Add a row for each speed entry\r\n    if (item.speedEntries && item.speedEntries.length > 0) {\r\n      item.speedEntries.forEach(s => {\r\n        const entryTime = s.timestamp ? new Date(s.timestamp).toLocaleString() : '';\r\n        rows.push([\r\n          ...baseRow,\r\n          'Speed',\r\n          entryTime,\r\n          '', '', '', '',\r\n          s.speed.toString(),\r\n          '', '', '', '', '', '', '',\r\n          submittedAt,\r\n        ]);\r\n      });\r\n    }\r\n\r\n    // Add a row for each sachet mass entry\r\n    if (item.sachetMassEntries && item.sachetMassEntries.length > 0) {\r\n      item.sachetMassEntries.forEach(sm => {\r\n        const entryTime = sm.timestamp ? new Date(sm.timestamp).toLocaleString() : '';\r\n        rows.push([\r\n          ...baseRow,\r\n          'Sachet Mass',\r\n          entryTime,\r\n          '', '', '', '', '',\r\n          sm.mass.toString(),\r\n          '', '', '', '', '', '',\r\n          submittedAt,\r\n        ]);\r\n      });\r\n    }\r\n\r\n    // Add a row for each loose cases entry\r\n    if (item.looseCasesEntries && item.looseCasesEntries.length > 0) {\r\n      item.looseCasesEntries.forEach(lc => {\r\n        const entryTime = lc.timestamp ? new Date(lc.timestamp).toLocaleString() : '';\r\n        rows.push([\r\n          ...baseRow,\r\n          'Loose Cases',\r\n          entryTime,\r\n          '', '', '', '', '', '',\r\n          lc.batchNumber,\r\n          lc.cases.toString(),\r\n          '', '', '', '',\r\n          submittedAt,\r\n        ]);\r\n      });\r\n    }\r\n\r\n    // Add a row for each pallet scan entry\r\n    if (item.palletScanEntries && item.palletScanEntries.length > 0) {\r\n      item.palletScanEntries.forEach(ps => {\r\n        const entryTime = ps.timestamp ? new Date(ps.timestamp).toLocaleString() : '';\r\n        rows.push([\r\n          ...baseRow,\r\n          'Pallet Scan',\r\n          entryTime,\r\n          '', '', '', '', '', '', '', '',\r\n          ps.qrCode || '',\r\n          ps.batchNumber || '',\r\n          ps.palletNumber?.toString() || '',\r\n          ps.casesCount?.toString() || '',\r\n          submittedAt,\r\n        ]);\r\n      });\r\n    }\r\n\r\n    // If no entries at all, still add one summary row\r\n    const hasNoEntries =\r\n      (!item.wasteEntries || item.wasteEntries.length === 0) &&\r\n      (!item.downtimeEntries || item.downtimeEntries.length === 0) &&\r\n      (!item.speedEntries || item.speedEntries.length === 0) &&\r\n      (!item.sachetMassEntries || item.sachetMassEntries.length === 0) &&\r\n      (!item.looseCasesEntries || item.looseCasesEntries.length === 0) &&\r\n      (!item.palletScanEntries || item.palletScanEntries.length === 0);\r\n\r\n    if (hasNoEntries) {\r\n      rows.push([\r\n        ...baseRow,\r\n        'Summary',\r\n        '',\r\n        '',\r\n        (item.totalWaste || 0).toFixed(2),\r\n        '',\r\n        (item.totalDowntime || 0).toString(),\r\n        '', '', '', '', '', '', '', '',\r\n        submittedAt,\r\n      ]);\r\n    }\r\n  });\r\n\r\n  const csvContent = [\r\n    headers.join(','),\r\n    ...rows.map(row => row.map(cell => `\"${cell}\"`).join(',')),\r\n  ].join('\\n');\r\n\r\n  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\r\n  const link = document.createElement('a');\r\n  const url = URL.createObjectURL(blob);\r\n  link.setAttribute('href', url);\r\n  link.setAttribute('download', `${filename}.csv`);\r\n  link.style.visibility = 'hidden';\r\n  document.body.appendChild(link);\r\n  link.click();\r\n  document.body.removeChild(link);\r\n  // Clean up the object URL to prevent memory leak\r\n  URL.revokeObjectURL(url);\r\n};\r\n\r\n// Clear all history (for testing)\r\nexport const clearHistory = (): void => {\r\n  localStorage.removeItem(STORAGE_KEY);\r\n  localStorage.removeItem(MACHINES_KEY);\r\n};\r\n\r\n// ==========================================\r\n// SHARED LINE SPEED - Syncs across sub-machines\r\n// ==========================================\r\n\r\nconst LINE_SPEED_KEY_PREFIX = 'line_speed_';\r\n\r\n/**\r\n * Extract parent machine name from a sub-machine name\r\n * e.g., \"Cubes - Machine 1\" â†’ \"Cubes\"\r\n * e.g., \"Universal 2 - Machine 3\" â†’ \"Universal 2\"\r\n */\r\nexport const getParentMachineName = (machineName: string): string => {\r\n  // Check if it matches the pattern \"Parent - Machine N\"\r\n  const match = machineName.match(/^(.+?)\\s*-\\s*Machine\\s*\\d+$/i);\r\n  if (match) {\r\n    return match[1].trim();\r\n  }\r\n  // Return the original name if no sub-machine pattern found\r\n  return machineName;\r\n};\r\n\r\n/**\r\n * Get the storage key for shared line speed\r\n */\r\nconst getLineSpeedKey = (parentMachineName: string, shift: string, date: string): string => {\r\n  return `${LINE_SPEED_KEY_PREFIX}${parentMachineName}_${shift}_${date}`;\r\n};\r\n\r\n/**\r\n * Save shared line speed (called when any sub-machine sets speed)\r\n */\r\nexport const saveLineSpeed = (\r\n  machineName: string,\r\n  shift: string,\r\n  date: string,\r\n  speed: number\r\n): void => {\r\n  const parentName = getParentMachineName(machineName);\r\n  const key = getLineSpeedKey(parentName, shift, date);\r\n\r\n  const data = {\r\n    speed,\r\n    updatedAt: new Date().toISOString(),\r\n    updatedBy: machineName,\r\n  };\r\n\r\n  localStorage.setItem(key, JSON.stringify(data));\r\n  console.log(`ðŸ’¾ Saved line speed ${speed} PPM for ${parentName}`);\r\n};\r\n\r\n/**\r\n * Get shared line speed (returns the speed set by any sibling machine)\r\n */\r\nexport const getLineSpeed = (\r\n  machineName: string,\r\n  shift: string,\r\n  date: string\r\n): { speed: number; updatedBy: string; updatedAt: string } | null => {\r\n  const parentName = getParentMachineName(machineName);\r\n  const key = getLineSpeedKey(parentName, shift, date);\r\n\r\n  const stored = localStorage.getItem(key);\r\n  if (!stored) return null;\r\n\r\n  try {\r\n    const data = JSON.parse(stored);\r\n    console.log(`ðŸ“– Loaded line speed ${data.speed} PPM for ${parentName} (set by ${data.updatedBy})`);\r\n    return data;\r\n  } catch {\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Clear shared line speed (called when session ends)\r\n */\r\nexport const clearLineSpeed = (\r\n  machineName: string,\r\n  shift: string,\r\n  date: string\r\n): void => {\r\n  const parentName = getParentMachineName(machineName);\r\n  const key = getLineSpeedKey(parentName, shift, date);\r\n  localStorage.removeItem(key);\r\n};\r\n\r\n/**\r\n * Clean up old line speed entries (called periodically)\r\n */\r\nexport const cleanupOldLineSpeeds = (retentionDays: number = 7): number => {\r\n  const cutoff = Date.now() - (retentionDays * 24 * 60 * 60 * 1000);\r\n  let removed = 0;\r\n\r\n  for (let i = localStorage.length - 1; i >= 0; i--) {\r\n    const key = localStorage.key(i);\r\n    if (key?.startsWith(LINE_SPEED_KEY_PREFIX)) {\r\n      try {\r\n        const data = localStorage.getItem(key);\r\n        if (data) {\r\n          const parsed = JSON.parse(data);\r\n          const updatedAt = new Date(parsed.updatedAt).getTime();\r\n          if (updatedAt < cutoff) {\r\n            localStorage.removeItem(key);\r\n            removed++;\r\n          }\r\n        }\r\n      } catch {\r\n        // Invalid data - remove it\r\n        localStorage.removeItem(key);\r\n        removed++;\r\n      }\r\n    }\r\n  }\r\n\r\n  return removed;\r\n};\r\n\r\n/**\r\n * Clean up ALL stale session-related localStorage data\r\n * This removes old shift sessions, production timers, and current machine orders\r\n * that are older than the retention period\r\n */\r\nexport const cleanupAllStaleData = (retentionDays: number = 1): number => {\r\n  const cutoff = Date.now() - (retentionDays * 24 * 60 * 60 * 1000);\r\n  let removed = 0;\r\n\r\n  // Patterns to clean up\r\n  const patterns = [\r\n    'shift_session_',\r\n    'production_timer_',\r\n    'current_machine_order_',\r\n  ];\r\n\r\n  for (let i = localStorage.length - 1; i >= 0; i--) {\r\n    const key = localStorage.key(i);\r\n    if (!key) continue;\r\n\r\n    // Check if key matches any of our patterns\r\n    const matchesPattern = patterns.some(pattern => key.startsWith(pattern));\r\n    if (!matchesPattern) continue;\r\n\r\n    try {\r\n      const data = localStorage.getItem(key);\r\n      if (data) {\r\n        const parsed = JSON.parse(data);\r\n        // Check various timestamp fields\r\n        const timestamp = parsed.updatedAt || parsed.updated_at || parsed.timestamp || parsed.startTime;\r\n        if (timestamp) {\r\n          const dataTime = new Date(timestamp).getTime();\r\n          if (dataTime < cutoff) {\r\n            localStorage.removeItem(key);\r\n            removed++;\r\n            console.log(`ðŸ§¹ Cleaned up stale data: ${key}`);\r\n          }\r\n        }\r\n      }\r\n    } catch {\r\n      // Invalid data - remove it\r\n      localStorage.removeItem(key);\r\n      removed++;\r\n      console.log(`ðŸ§¹ Removed invalid data: ${key}`);\r\n    }\r\n  }\r\n\r\n  if (removed > 0) {\r\n    console.log(`ðŸ§¹ Total cleaned up: ${removed} stale localStorage entries`);\r\n  }\r\n\r\n  return removed;\r\n};\r\n\r\n/**\r\n * Run all cleanup routines\r\n */\r\nexport const runAllCleanup = (): void => {\r\n  cleanupAllStaleData(1); // Clean data older than 1 day\r\n  cleanupOldLineSpeeds(7); // Clean line speeds older than 7 days\r\n};\r\n"],"names":["MACHINES","WASTE_TYPES","DOWNTIME_REASONS","STORAGE_KEY","MACHINES_KEY","FAILED_SUBMISSIONS_KEY","getFailedSubmissions","stored","localStorage","getItem","JSON","parse","_unused","addFailedSubmission","data","error","queue","newEntry","id","concat","Date","now","Math","random","toString","substr","timestamp","toISOString","retryCount","maxRetries","push","setItem","stringify","removeFailedSubmission","filtered","filter","s","retryFailedSubmissions","async","isSupabaseConfigured","succeeded","failed","remaining","length","submission","submitShiftData","shiftData","wasteEntries","downtimeEntries","speedEntries","sachetMassEntries","looseCasesEntries","palletScanEntries","e","updatedQueue","map","_objectSpread","String","maybeRunCleanup","lastCleanupKey","lastCleanup","lastDate","getTime","result","cleanupOldHistory","history","getShiftHistory","cutoffDate","HISTORY_MAX_DAYS","cleaned","item","date","slice","removed","console","log","useSupabase","machinesCache","machinesListeners","toLocalMachine","record","name","status","currentOperator","current_operator","currentOrder","current_order","currentShift","current_shift","lastSubmission","last_submission","todayWaste","today_waste","todayDowntime","today_downtime","subMachineCount","sub_machine_count","toSupabaseRecord","machine","initializeMachines","records","fetchMachines","defaultMachines","syncMachinesToSupabase","getMachinesDataLocal","subscribeToMachineUpdates","callback","unsubscribe","subscribeMachineChanges","forEach","listener","getCurrentMachines","l","_unused2","saveShiftData","existing","unshift","updateMachineLastSubmission","submittedAt","w","d","_unused3","getTodayStats","today","split","todayData","totalWaste","reduce","sum","totalDowntime","submissionCount","machineName","machines","getMachinesData","machineIndex","findIndex","m","getTimeAgo","updateMachine","machineId","updates","index","upsertMachine","addMachine","deleteMachine","removeMachine","diffMs","diffMins","floor","diffHours","diffDays","exportToCSV","filename","rows","baseRow","shift","operatorName","orderNumber","product","batchNumber","toLocaleString","entryTime","wasteType","waste","toFixed","downtimeReason","downtime","speed","sm","mass","lc","cases","ps","_ps$palletNumber","_ps$casesCount","qrCode","palletNumber","casesCount","csvContent","join","row","cell","blob","Blob","type","link","document","createElement","url","URL","createObjectURL","setAttribute","style","visibility","body","appendChild","click","removeChild","revokeObjectURL","LINE_SPEED_KEY_PREFIX","getParentMachineName","match","trim","getLineSpeedKey","parentMachineName","saveLineSpeed","parentName","key","updatedAt","updatedBy","getLineSpeed","_unused4","runAllCleanup","retentionDays","arguments","undefined","cutoff","patterns","i","some","pattern","startsWith","parsed","updated_at","startTime","removeItem","_unused6","cleanupAllStaleData","_unused5","cleanupOldLineSpeeds"],"ignoreList":[],"sourceRoot":""}