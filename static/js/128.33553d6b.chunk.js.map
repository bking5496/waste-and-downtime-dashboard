{"version":3,"file":"static/js/128.33553d6b.chunk.js","mappings":"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","sources":["lib/liveSession.ts","types.ts","lib/storage.ts"],"sourcesContent":["import { supabase, isSupabaseConfigured } from './supabase';\r\n\r\n// ==========================================\r\n// LIVE SESSIONS - Cross-device sync with offline fallback\r\n// ==========================================\r\n\r\nexport interface LiveSession {\r\n    id: string; // Format: \"machineName_shift_date\"\r\n    machine_name: string;\r\n    operator_name: string;\r\n    order_number: string;\r\n    product: string;\r\n    batch_number: string;\r\n    shift: string;\r\n    session_date: string;\r\n    is_locked: boolean;\r\n    total_waste?: number;\r\n    total_downtime?: number;\r\n    created_at?: string;\r\n    updated_at?: string;\r\n}\r\n\r\n// Generate session ID from components\r\nexport const getLiveSessionId = (machineName: string, shift: string, date: string): string => {\r\n    return `${machineName}_${shift}_${date}`;\r\n};\r\n\r\n// Cache for active sessions (used when offline or for quick lookups)\r\nlet sessionsCache: Map<string, LiveSession> = new Map();\r\nlet lastFetchTime: number = 0;\r\nconst CACHE_TTL_MS = 30000; // 30 seconds cache\r\n\r\n// ==========================================\r\n// UPSERT SESSION (Save/Update)\r\n// ==========================================\r\nexport const upsertLiveSession = async (session: {\r\n    machineName: string;\r\n    operatorName: string;\r\n    orderNumber: string;\r\n    product: string;\r\n    batchNumber: string;\r\n    shift: string;\r\n    date: string;\r\n    locked: boolean;\r\n    totalWaste?: number;\r\n    totalDowntime?: number;\r\n}): Promise<boolean> => {\r\n    const sessionId = getLiveSessionId(session.machineName, session.shift, session.date);\r\n\r\n    const liveSession: LiveSession = {\r\n        id: sessionId,\r\n        machine_name: session.machineName,\r\n        operator_name: session.operatorName,\r\n        order_number: session.orderNumber,\r\n        product: session.product,\r\n        batch_number: session.batchNumber,\r\n        shift: session.shift,\r\n        session_date: session.date,\r\n        is_locked: session.locked,\r\n        total_waste: session.totalWaste || 0,\r\n        total_downtime: session.totalDowntime || 0,\r\n        updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    // Always update local cache first\r\n    sessionsCache.set(sessionId, liveSession);\r\n\r\n    // Try to sync to Supabase\r\n    if (isSupabaseConfigured) {\r\n        try {\r\n            const { error } = await supabase\r\n                .from('live_sessions')\r\n                .upsert({\r\n                    id: sessionId,\r\n                    machine_name: session.machineName,\r\n                    operator_name: session.operatorName,\r\n                    order_number: session.orderNumber,\r\n                    product: session.product,\r\n                    batch_number: session.batchNumber,\r\n                    shift: session.shift,\r\n                    session_date: session.date,\r\n                    is_locked: session.locked,\r\n                    total_waste: session.totalWaste || 0,\r\n                    total_downtime: session.totalDowntime || 0,\r\n                    updated_at: new Date().toISOString(),\r\n                }, { onConflict: 'id' });\r\n\r\n            if (error) {\r\n                console.error('Failed to upsert live session:', error.message);\r\n                return false;\r\n            }\r\n            console.log('âœ… Live session synced to Supabase:', sessionId);\r\n            return true;\r\n        } catch (e) {\r\n            console.error('Failed to upsert live session:', e);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Offline - cached locally, will sync later\r\n    return true;\r\n};\r\n\r\n// ==========================================\r\n// DELETE SESSION (When submitted or cleared)\r\n// ==========================================\r\nexport const deleteLiveSession = async (\r\n    machineName: string,\r\n    shift: string,\r\n    date: string\r\n): Promise<boolean> => {\r\n    const sessionId = getLiveSessionId(machineName, shift, date);\r\n\r\n    // Remove from local cache\r\n    sessionsCache.delete(sessionId);\r\n\r\n    // Try to delete from Supabase\r\n    if (isSupabaseConfigured) {\r\n        try {\r\n            const { error } = await supabase\r\n                .from('live_sessions')\r\n                .delete()\r\n                .eq('id', sessionId);\r\n\r\n            if (error) {\r\n                console.error('Failed to delete live session:', error.message);\r\n                return false;\r\n            }\r\n            return true;\r\n        } catch (e) {\r\n            console.error('Failed to delete live session:', e);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\n// ==========================================\r\n// FETCH ACTIVE SESSIONS (For Dashboard)\r\n// ==========================================\r\nexport const fetchActiveSessions = async (): Promise<LiveSession[]> => {\r\n    const now = Date.now();\r\n    const today = new Date().toISOString().split('T')[0];\r\n\r\n    // Return cache if fresh and online fetch fails\r\n    const shouldUseCache = now - lastFetchTime < CACHE_TTL_MS;\r\n\r\n    if (isSupabaseConfigured) {\r\n        try {\r\n            const { data, error } = await supabase\r\n                .from('live_sessions')\r\n                .select('*')\r\n                .eq('session_date', today)\r\n                .eq('is_locked', true);\r\n\r\n            if (error) {\r\n                console.error('Failed to fetch live sessions:', error.message);\r\n                // Fall back to cache\r\n                return Array.from(sessionsCache.values()).filter(\r\n                    s => s.session_date === today && s.is_locked\r\n                );\r\n            }\r\n\r\n            // Update cache with fetched data\r\n            sessionsCache.clear();\r\n            (data || []).forEach(session => {\r\n                sessionsCache.set(session.id, session);\r\n            });\r\n            lastFetchTime = now;\r\n\r\n            console.log('ðŸ“‹ Fetched active sessions from Supabase:', (data || []).length, data?.map(s => s.machine_name));\r\n            return data || [];\r\n        } catch (e) {\r\n            console.error('Failed to fetch live sessions:', e);\r\n            // Fall back to cache\r\n            return Array.from(sessionsCache.values()).filter(\r\n                s => s.session_date === today && s.is_locked\r\n            );\r\n        }\r\n    }\r\n\r\n    // Offline - return cached sessions\r\n    if (shouldUseCache) {\r\n        return Array.from(sessionsCache.values()).filter(\r\n            s => s.session_date === today && s.is_locked\r\n        );\r\n    }\r\n\r\n    return [];\r\n};\r\n\r\n// ==========================================\r\n// FETCH SESSION BY MACHINE NAME\r\n// ==========================================\r\nexport const fetchLiveSessionByMachine = async (\r\n    machineName: string,\r\n    shift: string,\r\n    date: string\r\n): Promise<LiveSession | null> => {\r\n    const sessionId = getLiveSessionId(machineName, shift, date);\r\n\r\n    // Check cache first\r\n    if (sessionsCache.has(sessionId)) {\r\n        return sessionsCache.get(sessionId) || null;\r\n    }\r\n\r\n    if (!isSupabaseConfigured) {\r\n        return null;\r\n    }\r\n\r\n    try {\r\n        const { data, error } = await supabase\r\n            .from('live_sessions')\r\n            .select('*')\r\n            .eq('id', sessionId)\r\n            .eq('is_locked', true)\r\n            .maybeSingle();\r\n\r\n        if (error) {\r\n            console.error('Failed to fetch session:', error.message);\r\n            return null;\r\n        }\r\n\r\n        if (data) {\r\n            // Update cache\r\n            sessionsCache.set(sessionId, data);\r\n            console.log('ðŸ“‹ Restored session from Supabase:', machineName);\r\n        }\r\n\r\n        return data;\r\n    } catch (e) {\r\n        console.error('Failed to fetch session by machine:', e);\r\n        return null;\r\n    }\r\n};\r\n\r\n// ==========================================\r\n// GET ACTIVE SUB-MACHINES (Replacement for localStorage check)\r\n// ==========================================\r\nexport const getActiveSubMachinesFromSupabase = async (\r\n    parentMachineName: string,\r\n    subMachineCount: number\r\n): Promise<Set<number>> => {\r\n    const activeSet = new Set<number>();\r\n    const sessions = await fetchActiveSessions();\r\n\r\n    for (let i = 1; i <= subMachineCount; i++) {\r\n        const fullName = `${parentMachineName} - Machine ${i}`;\r\n        const isActive = sessions.some(s => s.machine_name === fullName && s.is_locked);\r\n        if (isActive) {\r\n            activeSet.add(i);\r\n        }\r\n    }\r\n\r\n    return activeSet;\r\n};\r\n\r\n// ==========================================\r\n// SUBSCRIBE TO SESSION CHANGES (Real-time)\r\n// ==========================================\r\nexport const subscribeToSessionChanges = (\r\n    onUpdate: (sessions: LiveSession[]) => void\r\n) => {\r\n    if (!isSupabaseConfigured) {\r\n        return () => { }; // No-op unsubscribe\r\n    }\r\n\r\n    const today = new Date().toISOString().split('T')[0];\r\n\r\n    const channel = supabase\r\n        .channel('live-sessions-changes')\r\n        .on(\r\n            'postgres_changes',\r\n            { event: '*', schema: 'public', table: 'live_sessions' },\r\n            async (payload) => {\r\n                console.log('ðŸ”„ Real-time session update received:', payload.eventType);\r\n                // Refetch all sessions on any change\r\n                const sessions = await fetchActiveSessions();\r\n                onUpdate(sessions);\r\n            }\r\n        )\r\n        .subscribe((status) => {\r\n            console.log('ðŸ“¡ Session subscription status:', status);\r\n        });\r\n\r\n    return () => {\r\n        supabase.removeChannel(channel);\r\n    };\r\n};\r\n\r\n// ==========================================\r\n// SYNC PENDING SESSIONS (On reconnection)\r\n// ==========================================\r\nexport const syncPendingSessions = async (): Promise<void> => {\r\n    if (!isSupabaseConfigured) return;\r\n\r\n    // Any sessions in cache that might not be synced yet\r\n    for (const session of Array.from(sessionsCache.values())) {\r\n        try {\r\n            await supabase\r\n                .from('live_sessions')\r\n                .upsert({\r\n                    id: session.id,\r\n                    machine_name: session.machine_name,\r\n                    operator_name: session.operator_name,\r\n                    order_number: session.order_number,\r\n                    product: session.product,\r\n                    batch_number: session.batch_number,\r\n                    shift: session.shift,\r\n                    session_date: session.session_date,\r\n                    is_locked: session.is_locked,\r\n                    updated_at: new Date().toISOString(),\r\n                }, { onConflict: 'id' });\r\n        } catch (e) {\r\n            console.error('Failed to sync session:', session.id, e);\r\n        }\r\n    }\r\n};\r\n\r\n// ==========================================\r\n// ACTIVITY FEED - Real-time machine events\r\n// ==========================================\r\n\r\nexport type ActivityEventType =\r\n    | 'machine_start'\r\n    | 'machine_pause'\r\n    | 'machine_resume'\r\n    | 'waste_recorded'\r\n    | 'downtime_recorded'\r\n    | 'pallet_scanned'\r\n    | 'cases_added'\r\n    | 'sachet_mass_added'\r\n    | 'shift_submitted'\r\n    | 'speed_recorded';\r\n\r\nexport interface ActivityEvent {\r\n    id: string;\r\n    type: ActivityEventType;\r\n    machine_name: string;\r\n    operator_name?: string;\r\n    message: string;\r\n    details?: string;\r\n    timestamp: Date;\r\n}\r\n\r\n// In-memory activity log (most recent first)\r\nlet activityLog: ActivityEvent[] = [];\r\nconst MAX_ACTIVITY_ITEMS = 50;\r\nlet activityListeners: ((events: ActivityEvent[]) => void)[] = [];\r\n\r\n// Add an activity event\r\nexport const addActivityEvent = (event: Omit<ActivityEvent, 'id' | 'timestamp'>) => {\r\n    const newEvent: ActivityEvent = {\r\n        ...event,\r\n        id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\r\n        timestamp: new Date(),\r\n    };\r\n\r\n    activityLog = [newEvent, ...activityLog].slice(0, MAX_ACTIVITY_ITEMS);\r\n\r\n    // Notify listeners\r\n    activityListeners.forEach(listener => listener([...activityLog]));\r\n\r\n    // Also broadcast to Supabase for cross-device sync\r\n    if (isSupabaseConfigured) {\r\n        broadcastActivityEvent(newEvent);\r\n    }\r\n};\r\n\r\n// Broadcast activity to other clients via Supabase Realtime\r\nconst broadcastActivityEvent = async (event: ActivityEvent) => {\r\n    try {\r\n        const channel = supabase.channel('activity-broadcast');\r\n        await channel.send({\r\n            type: 'broadcast',\r\n            event: 'activity',\r\n            payload: {\r\n                ...event,\r\n                timestamp: event.timestamp.toISOString(),\r\n            },\r\n        });\r\n    } catch (e) {\r\n        // Silently fail - activity feed is non-critical\r\n    }\r\n};\r\n\r\n// Subscribe to activity events\r\nexport const subscribeToActivityFeed = (\r\n    onUpdate: (events: ActivityEvent[]) => void\r\n) => {\r\n    // Add listener\r\n    activityListeners.push(onUpdate);\r\n\r\n    // Send current log immediately\r\n    onUpdate([...activityLog]);\r\n\r\n    // Subscribe to Supabase broadcast for cross-device events\r\n    let channel: ReturnType<typeof supabase.channel> | null = null;\r\n\r\n    if (isSupabaseConfigured) {\r\n        channel = supabase\r\n            .channel('activity-broadcast')\r\n            .on('broadcast', { event: 'activity' }, (payload) => {\r\n                const eventData = payload.payload as ActivityEvent & { timestamp: string };\r\n                const event: ActivityEvent = {\r\n                    ...eventData,\r\n                    timestamp: new Date(eventData.timestamp),\r\n                };\r\n\r\n                // Avoid duplicates\r\n                if (!activityLog.some(e => e.id === event.id)) {\r\n                    activityLog = [event, ...activityLog].slice(0, MAX_ACTIVITY_ITEMS);\r\n                    activityListeners.forEach(listener => listener([...activityLog]));\r\n                }\r\n            })\r\n            .subscribe();\r\n    }\r\n\r\n    // Return unsubscribe function\r\n    return () => {\r\n        activityListeners = activityListeners.filter(l => l !== onUpdate);\r\n        if (channel) {\r\n            supabase.removeChannel(channel);\r\n        }\r\n    };\r\n};\r\n\r\n// Get current activity log\r\nexport const getActivityLog = (): ActivityEvent[] => [...activityLog];\r\n\r\n// Clear activity log\r\nexport const clearActivityLog = () => {\r\n    activityLog = [];\r\n    activityListeners.forEach(listener => listener([]));\r\n};\r\n","export interface WasteEntry {\r\n  id: string;\r\n  waste: number;\r\n  wasteType: string;\r\n  timestamp: Date;\r\n}\r\n\r\nexport interface DowntimeEntry {\r\n  id: string;\r\n  downtime: number;\r\n  downtimeReason: string;\r\n  notes?: string;\r\n  timestamp: Date;\r\n}\r\n\r\n// Production timer state for tracking run time and pauses\r\nexport interface ProductionState {\r\n  isRunning: boolean;\r\n  startTime: Date | null;       // When production started\r\n  pausedAt: Date | null;        // When current pause began\r\n  totalRunTimeMs: number;       // Accumulated run time in milliseconds\r\n  lastResumedAt: Date | null;   // When last resumed from pause\r\n}\r\n\r\nexport interface SpeedEntry {\r\n  id: string;\r\n  speed: number;\r\n  timestamp: Date;\r\n}\r\n\r\nexport interface SachetMassEntry {\r\n  id: string;\r\n  mass: number; // in grams\r\n  timestamp: Date;\r\n  ignored?: boolean; // Can be set to ignore but not deleted\r\n}\r\n\r\n// Loose cases entry - for cases not part of a full pallet\r\nexport interface LooseCasesEntry {\r\n  id: string;\r\n  batchNumber: string; // 5-digit batch number\r\n  cases: number; // number of loose cases\r\n  timestamp: Date;\r\n  ignored?: boolean;\r\n}\r\n\r\n// Pallet Scan entry - QR code is 13 digits: BBBBBPPPPCCCC\r\n// B = batch number (5 digits), P = pallet number (4 digits), C = cases count (4 digits)\r\nexport interface PalletScanEntry {\r\n  id: string;\r\n  qrCode: string; // Full 13-digit QR code\r\n  batchNumber: string; // Extracted: first 5 digits\r\n  palletNumber: string; // Extracted: digits 6-9 (4 digits)\r\n  casesCount: number; // Extracted: last 4 digits\r\n  timestamp: Date;\r\n  ignored?: boolean;\r\n}\r\n\r\n// Legacy CasesPerHourEntry - kept for backwards compatibility\r\nexport interface CasesPerHourEntry {\r\n  id: string;\r\n  cases: number;\r\n  hour: number;\r\n  timestamp: Date;\r\n  ignored?: boolean;\r\n}\r\n\r\nexport interface ShiftData {\r\n  id: string;\r\n  operatorName: string;\r\n  machine: string;\r\n  subMachine?: string; // For machines that are groups (e.g., \"Universal 2 - Machine 1\")\r\n  orderNumber: string;\r\n  product: string;\r\n  batchNumber: string;\r\n  shift: string;\r\n  date: string;\r\n  wasteEntries: WasteEntry[];\r\n  downtimeEntries: DowntimeEntry[];\r\n  speedEntries?: SpeedEntry[];\r\n  sachetMassEntries?: SachetMassEntry[];\r\n  casesPerHourEntries?: CasesPerHourEntry[]; // Legacy - kept for backwards compatibility\r\n  looseCasesEntries?: LooseCasesEntry[]; // New: loose cases with batch number\r\n  palletScanEntries?: PalletScanEntry[];\r\n  submittedAt: Date;\r\n  totalWaste: number;\r\n  totalDowntime: number;\r\n}\r\n\r\nexport interface ShiftSession {\r\n  machineName: string;\r\n  operatorName: string;\r\n  orderNumber: string;\r\n  product: string;\r\n  batchNumber: string;\r\n  shift: string;\r\n  date: string;\r\n  locked: boolean; // Once set, these values are locked for the shift\r\n  // Entry data persisted with session\r\n  wasteEntries?: WasteEntry[];\r\n  downtimeEntries?: DowntimeEntry[];\r\n  speedEntries?: SpeedEntry[];\r\n  sachetMassEntries?: SachetMassEntry[];\r\n  casesPerHourEntries?: CasesPerHourEntry[]; // Legacy\r\n  looseCasesEntries?: LooseCasesEntry[]; // New\r\n  palletScanEntries?: PalletScanEntry[];\r\n}\r\n\r\nexport interface Machine {\r\n  id: string;\r\n  name: string;\r\n  status: 'running' | 'idle' | 'maintenance';\r\n  currentOperator?: string;\r\n  currentOrder?: string;\r\n  currentShift?: string;\r\n  lastSubmission?: string;\r\n  todayWaste?: number;\r\n  todayDowntime?: number;\r\n  subMachineCount?: number; // Number of sub-machines (e.g., 4 for \"Universal 2\")\r\n}\r\n\r\n// ==============================================\r\n// DEFAULT DATA\r\n// ==============================================\r\n\r\nexport const OPERATORS: string[] = [];\r\nexport const MACHINES: Machine[] = [];\r\n\r\n// Waste Types - common manufacturing waste categories\r\nexport const WASTE_TYPES: string[] = [\r\n  'Start-up Waste',\r\n  'Changeover Waste',\r\n  'Defective Product',\r\n  'Material Spillage',\r\n];\r\n\r\n// Downtime Reasons - categorized by planned vs unplanned\r\nexport const PLANNED_DOWNTIME_REASONS: string[] = [\r\n  'Scheduled Maintenance',\r\n  'Changeover',\r\n];\r\n\r\nexport const UNPLANNED_DOWNTIME_REASONS: string[] = [\r\n  'Machine Breakdown',\r\n  'Material Shortage',\r\n];\r\n\r\n// Combined downtime reasons for selection\r\nexport const DOWNTIME_REASONS: string[] = [\r\n  'Machine Breakdown',\r\n  'Scheduled Maintenance',\r\n  'Changeover',\r\n  'Material Shortage',\r\n];\r\n\r\nexport const ORDER_NUMBERS: string[] = [];\r\nexport const PRODUCTS: string[] = [];\r\nexport const BATCH_NUMBERS: string[] = [];\r\n\r\n","import { ShiftData, Machine, MACHINES } from '../types';\r\nimport {\r\n  fetchMachines,\r\n  upsertMachine,\r\n  removeMachine,\r\n  syncMachinesToSupabase,\r\n  subscribeMachineChanges,\r\n  MachineRecord,\r\n  submitShiftData,\r\n  isSupabaseConfigured\r\n} from './supabase';\r\n\r\nconst STORAGE_KEY = 'waste_downtime_history';\r\nconst MACHINES_KEY = 'machines_data';\r\nconst MACHINES_SYNC_KEY = 'machines_last_sync';\r\nconst FAILED_SUBMISSIONS_KEY = 'failed_submissions_queue';\r\nconst HISTORY_MAX_DAYS = 90; // Keep history for 90 days\r\nconst HISTORY_MAX_ENTRIES = 1000; // Maximum entries to keep\r\n\r\n// ==========================================\r\n// FAILED SUBMISSIONS RETRY QUEUE\r\n// ==========================================\r\n\r\ninterface FailedSubmission {\r\n  id: string;\r\n  timestamp: string;\r\n  retryCount: number;\r\n  maxRetries: number;\r\n  data: {\r\n    shiftData: any;\r\n    wasteEntries: any[];\r\n    downtimeEntries: any[];\r\n    speedEntries?: any[];\r\n    sachetMassEntries?: any[];\r\n    looseCasesEntries?: any[];\r\n    palletScanEntries?: any[];\r\n  };\r\n  error: string;\r\n}\r\n\r\n// Get failed submissions queue\r\nexport const getFailedSubmissions = (): FailedSubmission[] => {\r\n  const stored = localStorage.getItem(FAILED_SUBMISSIONS_KEY);\r\n  if (!stored) return [];\r\n  try {\r\n    return JSON.parse(stored);\r\n  } catch {\r\n    return [];\r\n  }\r\n};\r\n\r\n// Add a failed submission to the retry queue\r\nexport const addFailedSubmission = (\r\n  data: FailedSubmission['data'],\r\n  error: string\r\n): void => {\r\n  const queue = getFailedSubmissions();\r\n  const newEntry: FailedSubmission = {\r\n    id: `failed_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n    timestamp: new Date().toISOString(),\r\n    retryCount: 0,\r\n    maxRetries: 3,\r\n    data,\r\n    error,\r\n  };\r\n  queue.push(newEntry);\r\n  localStorage.setItem(FAILED_SUBMISSIONS_KEY, JSON.stringify(queue));\r\n};\r\n\r\n// Remove a submission from the failed queue\r\nexport const removeFailedSubmission = (id: string): void => {\r\n  const queue = getFailedSubmissions();\r\n  const filtered = queue.filter(s => s.id !== id);\r\n  localStorage.setItem(FAILED_SUBMISSIONS_KEY, JSON.stringify(filtered));\r\n};\r\n\r\n// Retry all failed submissions\r\nexport const retryFailedSubmissions = async (): Promise<{\r\n  succeeded: number;\r\n  failed: number;\r\n  remaining: number;\r\n}> => {\r\n  if (!isSupabaseConfigured) {\r\n    return { succeeded: 0, failed: 0, remaining: getFailedSubmissions().length };\r\n  }\r\n\r\n  const queue = getFailedSubmissions();\r\n  let succeeded = 0;\r\n  let failed = 0;\r\n\r\n  for (const submission of queue) {\r\n    if (submission.retryCount >= submission.maxRetries) {\r\n      // Max retries reached, keep in queue but don't retry\r\n      failed++;\r\n      continue;\r\n    }\r\n\r\n    try {\r\n      await submitShiftData(\r\n        submission.data.shiftData,\r\n        submission.data.wasteEntries,\r\n        submission.data.downtimeEntries,\r\n        submission.data.speedEntries,\r\n        submission.data.sachetMassEntries,\r\n        submission.data.looseCasesEntries,\r\n        submission.data.palletScanEntries\r\n      );\r\n      removeFailedSubmission(submission.id);\r\n      succeeded++;\r\n    } catch (e) {\r\n      // Update retry count\r\n      const updatedQueue = getFailedSubmissions().map(s =>\r\n        s.id === submission.id\r\n          ? { ...s, retryCount: s.retryCount + 1, error: String(e) }\r\n          : s\r\n      );\r\n      localStorage.setItem(FAILED_SUBMISSIONS_KEY, JSON.stringify(updatedQueue));\r\n      failed++;\r\n    }\r\n  }\r\n\r\n  return {\r\n    succeeded,\r\n    failed,\r\n    remaining: getFailedSubmissions().length,\r\n  };\r\n};\r\n\r\n// Clear all failed submissions (manual clear)\r\nexport const clearFailedSubmissions = (): void => {\r\n  localStorage.removeItem(FAILED_SUBMISSIONS_KEY);\r\n};\r\n\r\n// ==========================================\r\n// LOCALSTORAGE CLEANUP\r\n// ==========================================\r\n\r\n// Clean up old history entries\r\nexport const cleanupOldHistory = (): { removed: number; remaining: number } => {\r\n  const history = getShiftHistory();\r\n  const now = new Date();\r\n  const cutoffDate = new Date(now.getTime() - HISTORY_MAX_DAYS * 24 * 60 * 60 * 1000);\r\n\r\n  // Filter out entries older than cutoff date\r\n  let cleaned = history.filter(item => {\r\n    const itemDate = new Date(item.date);\r\n    return itemDate >= cutoffDate;\r\n  });\r\n\r\n  // Also limit to max entries (keep most recent)\r\n  if (cleaned.length > HISTORY_MAX_ENTRIES) {\r\n    cleaned = cleaned.slice(0, HISTORY_MAX_ENTRIES);\r\n  }\r\n\r\n  const removed = history.length - cleaned.length;\r\n\r\n  if (removed > 0) {\r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(cleaned));\r\n    console.log(`Cleaned up ${removed} old history entries`);\r\n  }\r\n\r\n  return { removed, remaining: cleaned.length };\r\n};\r\n\r\n// Get localStorage usage stats\r\nexport const getStorageStats = (): {\r\n  historyCount: number;\r\n  failedCount: number;\r\n  totalSizeKB: number;\r\n  oldestEntry: string | null;\r\n} => {\r\n  const history = getShiftHistory();\r\n  const failed = getFailedSubmissions();\r\n\r\n  // Estimate total localStorage size\r\n  let totalSize = 0;\r\n  for (let i = 0; i < localStorage.length; i++) {\r\n    const key = localStorage.key(i);\r\n    if (key) {\r\n      const value = localStorage.getItem(key) || '';\r\n      totalSize += key.length + value.length;\r\n    }\r\n  }\r\n\r\n  const oldestEntry = history.length > 0\r\n    ? history[history.length - 1].date\r\n    : null;\r\n\r\n  return {\r\n    historyCount: history.length,\r\n    failedCount: failed.length,\r\n    totalSizeKB: Math.round(totalSize / 1024),\r\n    oldestEntry,\r\n  };\r\n};\r\n\r\n// Run cleanup on app startup (debounced to run once per day)\r\nexport const maybeRunCleanup = (): void => {\r\n  const lastCleanupKey = 'last_storage_cleanup';\r\n  const lastCleanup = localStorage.getItem(lastCleanupKey);\r\n  const now = new Date();\r\n\r\n  if (lastCleanup) {\r\n    const lastDate = new Date(lastCleanup);\r\n    const hoursSinceCleanup = (now.getTime() - lastDate.getTime()) / (1000 * 60 * 60);\r\n    if (hoursSinceCleanup < 24) {\r\n      return; // Already cleaned up today\r\n    }\r\n  }\r\n\r\n  // Run cleanup\r\n  const result = cleanupOldHistory();\r\n  localStorage.setItem(lastCleanupKey, now.toISOString());\r\n\r\n  if (result.removed > 0) {\r\n    console.log(`Storage cleanup: removed ${result.removed} entries, ${result.remaining} remaining`);\r\n  }\r\n};\r\n\r\n// Flag to track if we're using Supabase\r\nlet useSupabase = true;\r\nlet machinesCache: Machine[] | null = null;\r\nlet machinesListeners: ((machines: Machine[]) => void)[] = [];\r\n\r\n// Convert Supabase record to local Machine type\r\nconst toLocalMachine = (record: MachineRecord): Machine => ({\r\n  id: record.id,\r\n  name: record.name,\r\n  status: record.status,\r\n  currentOperator: record.current_operator,\r\n  currentOrder: record.current_order,\r\n  currentShift: record.current_shift,\r\n  lastSubmission: record.last_submission,\r\n  todayWaste: record.today_waste,\r\n  todayDowntime: record.today_downtime,\r\n  subMachineCount: record.sub_machine_count,\r\n});\r\n\r\n// Convert local Machine to Supabase record\r\nconst toSupabaseRecord = (machine: Machine): MachineRecord => ({\r\n  id: machine.id,\r\n  name: machine.name,\r\n  status: machine.status,\r\n  current_operator: machine.currentOperator,\r\n  current_order: machine.currentOrder,\r\n  current_shift: machine.currentShift,\r\n  last_submission: machine.lastSubmission,\r\n  today_waste: machine.todayWaste,\r\n  today_downtime: machine.todayDowntime,\r\n  sub_machine_count: machine.subMachineCount,\r\n});\r\n\r\n// Initialize machines from Supabase\r\nexport const initializeMachines = async (): Promise<Machine[]> => {\r\n  try {\r\n    const records = await fetchMachines();\r\n\r\n    if (records.length > 0) {\r\n      machinesCache = records.map(toLocalMachine);\r\n      // Also save to localStorage as backup\r\n      localStorage.setItem(MACHINES_KEY, JSON.stringify(machinesCache));\r\n      localStorage.setItem(MACHINES_SYNC_KEY, new Date().toISOString());\r\n      return machinesCache;\r\n    } else {\r\n      // No machines in Supabase, sync default machines\r\n      console.log('No machines in Supabase, syncing defaults...');\r\n      const defaultMachines = MACHINES.map(toSupabaseRecord);\r\n      await syncMachinesToSupabase(defaultMachines);\r\n      machinesCache = MACHINES;\r\n      localStorage.setItem(MACHINES_KEY, JSON.stringify(MACHINES));\r\n      return MACHINES;\r\n    }\r\n  } catch (error) {\r\n    console.error('Failed to initialize from Supabase, using localStorage:', error);\r\n    useSupabase = false;\r\n    return getMachinesDataLocal();\r\n  }\r\n};\r\n\r\n// Subscribe to real-time machine updates - OPTIMIZED\r\nexport const subscribeToMachineUpdates = (callback: (machines: Machine[]) => void) => {\r\n  machinesListeners.push(callback);\r\n\r\n  // Provide current machines getter for optimized real-time updates\r\n  const getCurrentMachines = (): MachineRecord[] => {\r\n    const current = machinesCache || getMachinesDataLocal();\r\n    return current.map(toSupabaseRecord);\r\n  };\r\n\r\n  // Set up Supabase real-time subscription with optimized handler\r\n  const unsubscribe = subscribeMachineChanges(\r\n    (records) => {\r\n      machinesCache = records.map(toLocalMachine);\r\n      localStorage.setItem(MACHINES_KEY, JSON.stringify(machinesCache));\r\n\r\n      // Notify all listeners\r\n      machinesListeners.forEach(listener => listener(machinesCache!));\r\n    },\r\n    getCurrentMachines\r\n  );\r\n\r\n  // Return cleanup function\r\n  return () => {\r\n    machinesListeners = machinesListeners.filter(l => l !== callback);\r\n    if (machinesListeners.length === 0) {\r\n      unsubscribe();\r\n    }\r\n  };\r\n};\r\n\r\n// Get machines from localStorage (fallback)\r\nconst getMachinesDataLocal = (): Machine[] => {\r\n  const stored = localStorage.getItem(MACHINES_KEY);\r\n  if (!stored) {\r\n    localStorage.setItem(MACHINES_KEY, JSON.stringify(MACHINES));\r\n    return MACHINES;\r\n  }\r\n\r\n  try {\r\n    return JSON.parse(stored);\r\n  } catch {\r\n    return MACHINES;\r\n  }\r\n};\r\n\r\n// Save shift data to local storage\r\nexport const saveShiftData = (data: ShiftData): void => {\r\n  const existing = getShiftHistory();\r\n  existing.unshift(data);\r\n  localStorage.setItem(STORAGE_KEY, JSON.stringify(existing));\r\n\r\n  // Update machine data\r\n  updateMachineLastSubmission(data.machine, data.submittedAt.toISOString());\r\n};\r\n\r\n// Get all shift history\r\nexport const getShiftHistory = (): ShiftData[] => {\r\n  const stored = localStorage.getItem(STORAGE_KEY);\r\n  if (!stored) return [];\r\n\r\n  try {\r\n    const parsed = JSON.parse(stored);\r\n    return parsed.map((item: any) => ({\r\n      ...item,\r\n      submittedAt: new Date(item.submittedAt),\r\n      wasteEntries: item.wasteEntries.map((w: any) => ({\r\n        ...w,\r\n        timestamp: new Date(w.timestamp),\r\n      })),\r\n      downtimeEntries: item.downtimeEntries.map((d: any) => ({\r\n        ...d,\r\n        timestamp: new Date(d.timestamp),\r\n      })),\r\n    }));\r\n  } catch {\r\n    return [];\r\n  }\r\n};\r\n\r\n// Get shift history for a specific date range\r\nexport const getShiftHistoryByDateRange = (startDate: Date, endDate: Date): ShiftData[] => {\r\n  const history = getShiftHistory();\r\n  return history.filter(item => {\r\n    const itemDate = new Date(item.date);\r\n    return itemDate >= startDate && itemDate <= endDate;\r\n  });\r\n};\r\n\r\n// Get shift history for a specific machine\r\nexport const getShiftHistoryByMachine = (machineName: string): ShiftData[] => {\r\n  const history = getShiftHistory();\r\n  return history.filter(item => item.machine === machineName);\r\n};\r\n\r\n// Get today's statistics\r\nexport const getTodayStats = () => {\r\n  const today = new Date().toISOString().split('T')[0];\r\n  const history = getShiftHistory();\r\n  const todayData = history.filter(item => item.date === today);\r\n\r\n  const totalWaste = todayData.reduce((sum, item) => sum + item.totalWaste, 0);\r\n  const totalDowntime = todayData.reduce((sum, item) => sum + item.totalDowntime, 0);\r\n  const submissionCount = todayData.length;\r\n\r\n  return { totalWaste, totalDowntime, submissionCount };\r\n};\r\n\r\n// Update machine last submission\r\nexport const updateMachineLastSubmission = (machineName: string, timestamp: string): void => {\r\n  const machines = getMachinesData();\r\n  const machineIndex = machines.findIndex(m => m.name === machineName);\r\n  if (machineIndex !== -1) {\r\n    machines[machineIndex].lastSubmission = getTimeAgo(new Date(timestamp));\r\n  }\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(machines));\r\n};\r\n\r\n// Get machines data with local modifications\r\nexport const getMachinesData = (): Machine[] => {\r\n  // Return cache if available\r\n  if (machinesCache) {\r\n    return machinesCache;\r\n  }\r\n\r\n  // Otherwise return from localStorage\r\n  return getMachinesDataLocal();\r\n};\r\n\r\n// Update a single machine\r\nexport const updateMachine = async (machineId: string, updates: Partial<Machine>): Promise<void> => {\r\n  const machines = getMachinesData();\r\n  const index = machines.findIndex(m => m.id === machineId);\r\n  if (index !== -1) {\r\n    machines[index] = { ...machines[index], ...updates };\r\n    machinesCache = machines;\r\n    localStorage.setItem(MACHINES_KEY, JSON.stringify(machines));\r\n\r\n    // Sync to Supabase\r\n    if (useSupabase) {\r\n      try {\r\n        await upsertMachine(toSupabaseRecord(machines[index]));\r\n      } catch (error) {\r\n        console.error('Failed to sync machine update to Supabase:', error);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n// Add a new machine\r\nexport const addMachine = async (machine: Machine): Promise<void> => {\r\n  const machines = getMachinesData();\r\n  machines.push(machine);\r\n  machinesCache = machines;\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(machines));\r\n\r\n  // Sync to Supabase\r\n  if (useSupabase) {\r\n    try {\r\n      await upsertMachine(toSupabaseRecord(machine));\r\n    } catch (error) {\r\n      console.error('Failed to sync new machine to Supabase:', error);\r\n    }\r\n  }\r\n};\r\n\r\n// Delete a machine\r\nexport const deleteMachine = async (machineId: string): Promise<void> => {\r\n  const machines = getMachinesData();\r\n  const filtered = machines.filter(m => m.id !== machineId);\r\n  machinesCache = filtered;\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(filtered));\r\n\r\n  // Sync to Supabase\r\n  if (useSupabase) {\r\n    try {\r\n      await removeMachine(machineId);\r\n    } catch (error) {\r\n      console.error('Failed to delete machine from Supabase:', error);\r\n    }\r\n  }\r\n};\r\n\r\n// Reset machines to default\r\nexport const resetMachines = async (): Promise<void> => {\r\n  machinesCache = MACHINES;\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(MACHINES));\r\n\r\n  // Sync to Supabase\r\n  if (useSupabase) {\r\n    try {\r\n      await syncMachinesToSupabase(MACHINES.map(toSupabaseRecord));\r\n    } catch (error) {\r\n      console.error('Failed to reset machines in Supabase:', error);\r\n    }\r\n  }\r\n};\r\n\r\n// Helper function to format time ago\r\nexport const getTimeAgo = (date: Date): string => {\r\n  const now = new Date();\r\n  const diffMs = now.getTime() - date.getTime();\r\n  const diffMins = Math.floor(diffMs / 60000);\r\n  const diffHours = Math.floor(diffMins / 60);\r\n  const diffDays = Math.floor(diffHours / 24);\r\n\r\n  if (diffMins < 1) return 'Just now';\r\n  if (diffMins < 60) return `${diffMins} min ago`;\r\n  if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;\r\n  return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;\r\n};\r\n\r\n// Export data to CSV\r\nexport const exportToCSV = (data: ShiftData[], filename: string): void => {\r\n  const headers = [\r\n    'Date',\r\n    'Shift',\r\n    'Operator',\r\n    'Machine',\r\n    'Order Number',\r\n    'Product',\r\n    'Batch Number',\r\n    'Entry Type',\r\n    'Waste Type',\r\n    'Waste (kg)',\r\n    'Downtime Reason',\r\n    'Downtime (min)',\r\n    'Submitted At',\r\n  ];\r\n\r\n  const rows: string[][] = [];\r\n\r\n  data.forEach(item => {\r\n    const baseRow = [\r\n      item.date,\r\n      item.shift,\r\n      item.operatorName,\r\n      item.machine,\r\n      item.orderNumber,\r\n      item.product,\r\n      item.batchNumber,\r\n    ];\r\n    const submittedAt = new Date(item.submittedAt).toLocaleString();\r\n\r\n    // Add a row for each waste entry\r\n    if (item.wasteEntries && item.wasteEntries.length > 0) {\r\n      item.wasteEntries.forEach(w => {\r\n        rows.push([\r\n          ...baseRow,\r\n          'Waste',\r\n          w.wasteType,\r\n          w.waste.toFixed(2),\r\n          '',\r\n          '',\r\n          submittedAt,\r\n        ]);\r\n      });\r\n    }\r\n\r\n    // Add a row for each downtime entry\r\n    if (item.downtimeEntries && item.downtimeEntries.length > 0) {\r\n      item.downtimeEntries.forEach(d => {\r\n        rows.push([\r\n          ...baseRow,\r\n          'Downtime',\r\n          '',\r\n          '',\r\n          d.downtimeReason,\r\n          d.downtime.toString(),\r\n          submittedAt,\r\n        ]);\r\n      });\r\n    }\r\n\r\n    // If no entries at all, still add one summary row\r\n    if ((!item.wasteEntries || item.wasteEntries.length === 0) &&\r\n      (!item.downtimeEntries || item.downtimeEntries.length === 0)) {\r\n      rows.push([\r\n        ...baseRow,\r\n        'Summary',\r\n        '',\r\n        item.totalWaste.toFixed(2),\r\n        '',\r\n        item.totalDowntime.toString(),\r\n        submittedAt,\r\n      ]);\r\n    }\r\n  });\r\n\r\n  const csvContent = [\r\n    headers.join(','),\r\n    ...rows.map(row => row.map(cell => `\"${cell}\"`).join(',')),\r\n  ].join('\\n');\r\n\r\n  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\r\n  const link = document.createElement('a');\r\n  const url = URL.createObjectURL(blob);\r\n  link.setAttribute('href', url);\r\n  link.setAttribute('download', `${filename}.csv`);\r\n  link.style.visibility = 'hidden';\r\n  document.body.appendChild(link);\r\n  link.click();\r\n  document.body.removeChild(link);\r\n  // Clean up the object URL to prevent memory leak\r\n  URL.revokeObjectURL(url);\r\n};\r\n\r\n// Clear all history (for testing)\r\nexport const clearHistory = (): void => {\r\n  localStorage.removeItem(STORAGE_KEY);\r\n  localStorage.removeItem(MACHINES_KEY);\r\n};\r\n\r\n// ==========================================\r\n// SHARED LINE SPEED - Syncs across sub-machines\r\n// ==========================================\r\n\r\nconst LINE_SPEED_KEY_PREFIX = 'line_speed_';\r\n\r\n/**\r\n * Extract parent machine name from a sub-machine name\r\n * e.g., \"Cubes - Machine 1\" â†’ \"Cubes\"\r\n * e.g., \"Universal 2 - Machine 3\" â†’ \"Universal 2\"\r\n */\r\nexport const getParentMachineName = (machineName: string): string => {\r\n  // Check if it matches the pattern \"Parent - Machine N\"\r\n  const match = machineName.match(/^(.+?)\\s*-\\s*Machine\\s*\\d+$/i);\r\n  if (match) {\r\n    return match[1].trim();\r\n  }\r\n  // Return the original name if no sub-machine pattern found\r\n  return machineName;\r\n};\r\n\r\n/**\r\n * Get the storage key for shared line speed\r\n */\r\nconst getLineSpeedKey = (parentMachineName: string, shift: string, date: string): string => {\r\n  return `${LINE_SPEED_KEY_PREFIX}${parentMachineName}_${shift}_${date}`;\r\n};\r\n\r\n/**\r\n * Save shared line speed (called when any sub-machine sets speed)\r\n */\r\nexport const saveLineSpeed = (\r\n  machineName: string,\r\n  shift: string,\r\n  date: string,\r\n  speed: number\r\n): void => {\r\n  const parentName = getParentMachineName(machineName);\r\n  const key = getLineSpeedKey(parentName, shift, date);\r\n\r\n  const data = {\r\n    speed,\r\n    updatedAt: new Date().toISOString(),\r\n    updatedBy: machineName,\r\n  };\r\n\r\n  localStorage.setItem(key, JSON.stringify(data));\r\n  console.log(`ðŸ’¾ Saved line speed ${speed} PPM for ${parentName}`);\r\n};\r\n\r\n/**\r\n * Get shared line speed (returns the speed set by any sibling machine)\r\n */\r\nexport const getLineSpeed = (\r\n  machineName: string,\r\n  shift: string,\r\n  date: string\r\n): { speed: number; updatedBy: string; updatedAt: string } | null => {\r\n  const parentName = getParentMachineName(machineName);\r\n  const key = getLineSpeedKey(parentName, shift, date);\r\n\r\n  const stored = localStorage.getItem(key);\r\n  if (!stored) return null;\r\n\r\n  try {\r\n    const data = JSON.parse(stored);\r\n    console.log(`ðŸ“– Loaded line speed ${data.speed} PPM for ${parentName} (set by ${data.updatedBy})`);\r\n    return data;\r\n  } catch {\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Clear shared line speed (called when session ends)\r\n */\r\nexport const clearLineSpeed = (\r\n  machineName: string,\r\n  shift: string,\r\n  date: string\r\n): void => {\r\n  const parentName = getParentMachineName(machineName);\r\n  const key = getLineSpeedKey(parentName, shift, date);\r\n  localStorage.removeItem(key);\r\n};\r\n\r\n/**\r\n * Clean up old line speed entries (called periodically)\r\n */\r\nexport const cleanupOldLineSpeeds = (retentionDays: number = 7): number => {\r\n  const cutoff = Date.now() - (retentionDays * 24 * 60 * 60 * 1000);\r\n  let removed = 0;\r\n\r\n  for (let i = localStorage.length - 1; i >= 0; i--) {\r\n    const key = localStorage.key(i);\r\n    if (key?.startsWith(LINE_SPEED_KEY_PREFIX)) {\r\n      try {\r\n        const data = localStorage.getItem(key);\r\n        if (data) {\r\n          const parsed = JSON.parse(data);\r\n          const updatedAt = new Date(parsed.updatedAt).getTime();\r\n          if (updatedAt < cutoff) {\r\n            localStorage.removeItem(key);\r\n            removed++;\r\n          }\r\n        }\r\n      } catch {\r\n        // Invalid data - remove it\r\n        localStorage.removeItem(key);\r\n        removed++;\r\n      }\r\n    }\r\n  }\r\n\r\n  return removed;\r\n};\r\n"],"names":["getLiveSessionId","machineName","shift","date","concat","sessionsCache","Map","lastFetchTime","upsertLiveSession","async","sessionId","session","liveSession","id","machine_name","operator_name","operatorName","order_number","orderNumber","product","batch_number","batchNumber","session_date","is_locked","locked","total_waste","totalWaste","total_downtime","totalDowntime","updated_at","Date","toISOString","set","isSupabaseConfigured","error","supabase","from","upsert","onConflict","console","message","log","e","deleteLiveSession","delete","eq","fetchActiveSessions","now","today","split","shouldUseCache","data","select","Array","values","filter","s","clear","forEach","length","map","fetchLiveSessionByMachine","has","get","maybeSingle","subscribeToSessionChanges","onUpdate","channel","on","event","schema","table","payload","eventType","sessions","subscribe","status","removeChannel","activityLog","activityListeners","addActivityEvent","newEvent","_objectSpread","Math","random","toString","substr","timestamp","slice","listener","broadcastActivityEvent","send","type","subscribeToActivityFeed","push","eventData","some","l","MACHINES","WASTE_TYPES","DOWNTIME_REASONS","STORAGE_KEY","MACHINES_KEY","FAILED_SUBMISSIONS_KEY","getFailedSubmissions","stored","localStorage","getItem","JSON","parse","_unused","addFailedSubmission","queue","newEntry","retryCount","maxRetries","setItem","stringify","removeFailedSubmission","filtered","retryFailedSubmissions","succeeded","failed","remaining","submission","submitShiftData","shiftData","wasteEntries","downtimeEntries","speedEntries","sachetMassEntries","looseCasesEntries","palletScanEntries","updatedQueue","String","maybeRunCleanup","lastCleanupKey","lastCleanup","lastDate","getTime","result","cleanupOldHistory","history","getShiftHistory","cutoffDate","HISTORY_MAX_DAYS","cleaned","item","removed","useSupabase","machinesCache","machinesListeners","toLocalMachine","record","name","currentOperator","current_operator","currentOrder","current_order","currentShift","current_shift","lastSubmission","last_submission","todayWaste","today_waste","todayDowntime","today_downtime","subMachineCount","sub_machine_count","toSupabaseRecord","machine","initializeMachines","records","fetchMachines","defaultMachines","syncMachinesToSupabase","getMachinesDataLocal","subscribeToMachineUpdates","callback","unsubscribe","subscribeMachineChanges","getCurrentMachines","_unused2","saveShiftData","existing","unshift","updateMachineLastSubmission","submittedAt","w","d","_unused3","getTodayStats","todayData","reduce","sum","submissionCount","machines","getMachinesData","machineIndex","findIndex","m","getTimeAgo","updateMachine","machineId","updates","index","upsertMachine","addMachine","deleteMachine","removeMachine","diffMs","diffMins","floor","diffHours","diffDays","exportToCSV","filename","rows","baseRow","toLocaleString","wasteType","waste","toFixed","downtimeReason","downtime","csvContent","join","row","cell","blob","Blob","link","document","createElement","url","URL","createObjectURL","setAttribute","style","visibility","body","appendChild","click","removeChild","revokeObjectURL","LINE_SPEED_KEY_PREFIX","getParentMachineName","match","trim","getLineSpeedKey","parentMachineName","saveLineSpeed","speed","parentName","key","updatedAt","updatedBy","getLineSpeed","_unused4"],"ignoreList":[],"sourceRoot":""}