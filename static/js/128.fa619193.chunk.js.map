{"version":3,"file":"static/js/128.fa619193.chunk.js","mappings":"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","sources":["lib/liveSession.ts","types.ts","lib/storage.ts"],"sourcesContent":["import { supabase, isSupabaseConfigured } from './supabase';\r\n\r\n// ==========================================\r\n// LIVE SESSIONS - Cross-device sync with offline fallback\r\n// ==========================================\r\n\r\nexport interface LiveSession {\r\n    id: string; // Format: \"machineName_shift_date\"\r\n    machine_name: string;\r\n    operator_name: string;\r\n    order_number: string;\r\n    product: string;\r\n    batch_number: string;\r\n    shift: string;\r\n    session_date: string;\r\n    is_locked: boolean;\r\n    total_waste?: number;\r\n    total_downtime?: number;\r\n    // JSON-encoded entries for cross-device sync\r\n    entries_json?: string;\r\n    created_at?: string;\r\n    updated_at?: string;\r\n}\r\n\r\n// Entry types for cross-device sync\r\nexport interface SyncedWasteEntry {\r\n    id: string;\r\n    waste: number;\r\n    wasteType: string;\r\n    timestamp: string;\r\n}\r\n\r\nexport interface SyncedDowntimeEntry {\r\n    id: string;\r\n    downtime: number;\r\n    downtimeReason: string;\r\n    timestamp: string;\r\n}\r\n\r\nexport interface SyncedSpeedEntry {\r\n    id: string;\r\n    speed: number;\r\n    timestamp: string;\r\n}\r\n\r\nexport interface SyncedSachetMassEntry {\r\n    id: string;\r\n    mass: number;\r\n    timestamp: string;\r\n}\r\n\r\nexport interface SyncedLooseCasesEntry {\r\n    id: string;\r\n    batchNumber: string;\r\n    cases: number;\r\n    timestamp: string;\r\n}\r\n\r\nexport interface SyncedPalletScanEntry {\r\n    id: string;\r\n    qrCode: string;\r\n    batchNumber: string;\r\n    palletNumber: string;\r\n    casesCount: number;\r\n    timestamp: string;\r\n    ignored?: boolean;\r\n}\r\n\r\nexport interface SyncedEntries {\r\n    wasteEntries: SyncedWasteEntry[];\r\n    downtimeEntries: SyncedDowntimeEntry[];\r\n    speedEntries: SyncedSpeedEntry[];\r\n    sachetMassEntries: SyncedSachetMassEntry[];\r\n    looseCasesEntries: SyncedLooseCasesEntry[];\r\n    palletScanEntries: SyncedPalletScanEntry[];\r\n}\r\n\r\n// Generate session ID from components\r\nexport const getLiveSessionId = (machineName: string, shift: string, date: string): string => {\r\n    return `${machineName}_${shift}_${date}`;\r\n};\r\n\r\n// Cache for active sessions (used when offline or for quick lookups)\r\nlet sessionsCache: Map<string, LiveSession> = new Map();\r\nlet lastFetchTime: number = 0;\r\nconst CACHE_TTL_MS = 30000; // 30 seconds cache\r\n\r\n// ==========================================\r\n// UPSERT SESSION (Save/Update)\r\n// ==========================================\r\nexport const upsertLiveSession = async (session: {\r\n    machineName: string;\r\n    operatorName: string;\r\n    orderNumber: string;\r\n    product: string;\r\n    batchNumber: string;\r\n    shift: string;\r\n    date: string;\r\n    locked: boolean;\r\n    totalWaste?: number;\r\n    totalDowntime?: number;\r\n}): Promise<boolean> => {\r\n    const sessionId = getLiveSessionId(session.machineName, session.shift, session.date);\r\n\r\n    const liveSession: LiveSession = {\r\n        id: sessionId,\r\n        machine_name: session.machineName,\r\n        operator_name: session.operatorName,\r\n        order_number: session.orderNumber,\r\n        product: session.product,\r\n        batch_number: session.batchNumber,\r\n        shift: session.shift,\r\n        session_date: session.date,\r\n        is_locked: session.locked,\r\n        total_waste: session.totalWaste || 0,\r\n        total_downtime: session.totalDowntime || 0,\r\n        updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    // Always update local cache first\r\n    sessionsCache.set(sessionId, liveSession);\r\n\r\n    // Try to sync to Supabase\r\n    if (isSupabaseConfigured) {\r\n        try {\r\n            const { error } = await supabase\r\n                .from('live_sessions')\r\n                .upsert({\r\n                    id: sessionId,\r\n                    machine_name: session.machineName,\r\n                    operator_name: session.operatorName,\r\n                    order_number: session.orderNumber,\r\n                    product: session.product,\r\n                    batch_number: session.batchNumber,\r\n                    shift: session.shift,\r\n                    session_date: session.date,\r\n                    is_locked: session.locked,\r\n                    total_waste: session.totalWaste || 0,\r\n                    total_downtime: session.totalDowntime || 0,\r\n                    updated_at: new Date().toISOString(),\r\n                }, { onConflict: 'id' });\r\n\r\n            if (error) {\r\n                console.error('Failed to upsert live session:', error.message);\r\n                return false;\r\n            }\r\n            console.log('âœ… Live session synced to Supabase:', sessionId);\r\n            return true;\r\n        } catch (e) {\r\n            console.error('Failed to upsert live session:', e);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Offline - cached locally, will sync later\r\n    return true;\r\n};\r\n\r\n// ==========================================\r\n// DELETE SESSION (When submitted or cleared)\r\n// ==========================================\r\nexport const deleteLiveSession = async (\r\n    machineName: string,\r\n    shift: string,\r\n    date: string\r\n): Promise<boolean> => {\r\n    const sessionId = getLiveSessionId(machineName, shift, date);\r\n\r\n    // Remove from local cache\r\n    sessionsCache.delete(sessionId);\r\n\r\n    // Try to delete from Supabase\r\n    if (isSupabaseConfigured) {\r\n        try {\r\n            const { error } = await supabase\r\n                .from('live_sessions')\r\n                .delete()\r\n                .eq('id', sessionId);\r\n\r\n            if (error) {\r\n                console.error('Failed to delete live session:', error.message);\r\n                return false;\r\n            }\r\n            return true;\r\n        } catch (e) {\r\n            console.error('Failed to delete live session:', e);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\n// ==========================================\r\n// FETCH ACTIVE SESSIONS (For Dashboard)\r\n// ==========================================\r\nexport const fetchActiveSessions = async (): Promise<LiveSession[]> => {\r\n    const now = Date.now();\r\n    const today = new Date().toISOString().split('T')[0];\r\n\r\n    // Return cache if fresh and online fetch fails\r\n    const shouldUseCache = now - lastFetchTime < CACHE_TTL_MS;\r\n\r\n    if (isSupabaseConfigured) {\r\n        try {\r\n            const { data, error } = await supabase\r\n                .from('live_sessions')\r\n                .select('*')\r\n                .eq('session_date', today)\r\n                .eq('is_locked', true);\r\n\r\n            if (error) {\r\n                console.error('Failed to fetch live sessions:', error.message);\r\n                // Fall back to cache\r\n                return Array.from(sessionsCache.values()).filter(\r\n                    s => s.session_date === today && s.is_locked\r\n                );\r\n            }\r\n\r\n            // Update cache with fetched data\r\n            sessionsCache.clear();\r\n            (data || []).forEach(session => {\r\n                sessionsCache.set(session.id, session);\r\n            });\r\n            lastFetchTime = now;\r\n\r\n            console.log('ðŸ“‹ Fetched active sessions from Supabase:', (data || []).length, data?.map(s => s.machine_name));\r\n            return data || [];\r\n        } catch (e) {\r\n            console.error('Failed to fetch live sessions:', e);\r\n            // Fall back to cache\r\n            return Array.from(sessionsCache.values()).filter(\r\n                s => s.session_date === today && s.is_locked\r\n            );\r\n        }\r\n    }\r\n\r\n    // Offline - return cached sessions\r\n    if (shouldUseCache) {\r\n        return Array.from(sessionsCache.values()).filter(\r\n            s => s.session_date === today && s.is_locked\r\n        );\r\n    }\r\n\r\n    return [];\r\n};\r\n\r\n// ==========================================\r\n// FETCH SESSION BY MACHINE NAME\r\n// ==========================================\r\nexport const fetchLiveSessionByMachine = async (\r\n    machineName: string,\r\n    shift: string,\r\n    date: string\r\n): Promise<LiveSession | null> => {\r\n    const sessionId = getLiveSessionId(machineName, shift, date);\r\n\r\n    // Check cache first\r\n    if (sessionsCache.has(sessionId)) {\r\n        return sessionsCache.get(sessionId) || null;\r\n    }\r\n\r\n    if (!isSupabaseConfigured) {\r\n        return null;\r\n    }\r\n\r\n    try {\r\n        const { data, error } = await supabase\r\n            .from('live_sessions')\r\n            .select('*')\r\n            .eq('id', sessionId)\r\n            .eq('is_locked', true)\r\n            .maybeSingle();\r\n\r\n        if (error) {\r\n            console.error('Failed to fetch session:', error.message);\r\n            return null;\r\n        }\r\n\r\n        if (data) {\r\n            // Update cache\r\n            sessionsCache.set(sessionId, data);\r\n            console.log('ðŸ“‹ Restored session from Supabase:', machineName);\r\n        }\r\n\r\n        return data;\r\n    } catch (e) {\r\n        console.error('Failed to fetch session by machine:', e);\r\n        return null;\r\n    }\r\n};\r\n\r\n// ==========================================\r\n// GET ACTIVE SUB-MACHINES (Replacement for localStorage check)\r\n// ==========================================\r\nexport const getActiveSubMachinesFromSupabase = async (\r\n    parentMachineName: string,\r\n    subMachineCount: number\r\n): Promise<Set<number>> => {\r\n    const activeSet = new Set<number>();\r\n    const sessions = await fetchActiveSessions();\r\n\r\n    for (let i = 1; i <= subMachineCount; i++) {\r\n        const fullName = `${parentMachineName} - Machine ${i}`;\r\n        const isActive = sessions.some(s => s.machine_name === fullName && s.is_locked);\r\n        if (isActive) {\r\n            activeSet.add(i);\r\n        }\r\n    }\r\n\r\n    return activeSet;\r\n};\r\n\r\n// ==========================================\r\n// SUBSCRIBE TO SESSION CHANGES (Real-time)\r\n// ==========================================\r\nexport const subscribeToSessionChanges = (\r\n    onUpdate: (sessions: LiveSession[]) => void\r\n) => {\r\n    if (!isSupabaseConfigured) {\r\n        return () => { }; // No-op unsubscribe\r\n    }\r\n\r\n    const today = new Date().toISOString().split('T')[0];\r\n\r\n    const channel = supabase\r\n        .channel('live-sessions-changes')\r\n        .on(\r\n            'postgres_changes',\r\n            { event: '*', schema: 'public', table: 'live_sessions' },\r\n            async (payload) => {\r\n                console.log('ðŸ”„ Real-time session update received:', payload.eventType);\r\n                // Refetch all sessions on any change\r\n                const sessions = await fetchActiveSessions();\r\n                onUpdate(sessions);\r\n            }\r\n        )\r\n        .subscribe((status) => {\r\n            console.log('ðŸ“¡ Session subscription status:', status);\r\n        });\r\n\r\n    return () => {\r\n        supabase.removeChannel(channel);\r\n    };\r\n};\r\n\r\n// ==========================================\r\n// SYNC PENDING SESSIONS (On reconnection)\r\n// ==========================================\r\nexport const syncPendingSessions = async (): Promise<void> => {\r\n    if (!isSupabaseConfigured) return;\r\n\r\n    // Any sessions in cache that might not be synced yet\r\n    for (const session of Array.from(sessionsCache.values())) {\r\n        try {\r\n            await supabase\r\n                .from('live_sessions')\r\n                .upsert({\r\n                    id: session.id,\r\n                    machine_name: session.machine_name,\r\n                    operator_name: session.operator_name,\r\n                    order_number: session.order_number,\r\n                    product: session.product,\r\n                    batch_number: session.batch_number,\r\n                    shift: session.shift,\r\n                    session_date: session.session_date,\r\n                    is_locked: session.is_locked,\r\n                    updated_at: new Date().toISOString(),\r\n                }, { onConflict: 'id' });\r\n        } catch (e) {\r\n            console.error('Failed to sync session:', session.id, e);\r\n        }\r\n    }\r\n};\r\n\r\n// ==========================================\r\n// ACTIVITY FEED - Real-time machine events\r\n// ==========================================\r\n\r\nexport type ActivityEventType =\r\n    | 'machine_start'\r\n    | 'machine_pause'\r\n    | 'machine_resume'\r\n    | 'waste_recorded'\r\n    | 'downtime_recorded'\r\n    | 'pallet_scanned'\r\n    | 'cases_added'\r\n    | 'sachet_mass_added'\r\n    | 'shift_submitted'\r\n    | 'speed_recorded';\r\n\r\nexport interface ActivityEvent {\r\n    id: string;\r\n    type: ActivityEventType;\r\n    machine_name: string;\r\n    operator_name?: string;\r\n    message: string;\r\n    details?: string;\r\n    timestamp: Date;\r\n}\r\n\r\n// In-memory activity log (most recent first)\r\nlet activityLog: ActivityEvent[] = [];\r\nconst MAX_ACTIVITY_ITEMS = 50;\r\nlet activityListeners: ((events: ActivityEvent[]) => void)[] = [];\r\n\r\n// Add an activity event\r\nexport const addActivityEvent = (event: Omit<ActivityEvent, 'id' | 'timestamp'>) => {\r\n    const newEvent: ActivityEvent = {\r\n        ...event,\r\n        id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\r\n        timestamp: new Date(),\r\n    };\r\n\r\n    activityLog = [newEvent, ...activityLog].slice(0, MAX_ACTIVITY_ITEMS);\r\n\r\n    // Notify listeners\r\n    activityListeners.forEach(listener => listener([...activityLog]));\r\n\r\n    // Also broadcast to Supabase for cross-device sync\r\n    if (isSupabaseConfigured) {\r\n        broadcastActivityEvent(newEvent);\r\n    }\r\n};\r\n\r\n// Broadcast activity to other clients via Supabase Realtime\r\nconst broadcastActivityEvent = async (event: ActivityEvent) => {\r\n    try {\r\n        const channel = supabase.channel('activity-broadcast');\r\n        await channel.send({\r\n            type: 'broadcast',\r\n            event: 'activity',\r\n            payload: {\r\n                ...event,\r\n                timestamp: event.timestamp.toISOString(),\r\n            },\r\n        });\r\n    } catch (e) {\r\n        // Silently fail - activity feed is non-critical\r\n    }\r\n};\r\n\r\n// Subscribe to activity events\r\nexport const subscribeToActivityFeed = (\r\n    onUpdate: (events: ActivityEvent[]) => void\r\n) => {\r\n    // Add listener\r\n    activityListeners.push(onUpdate);\r\n\r\n    // Send current log immediately\r\n    onUpdate([...activityLog]);\r\n\r\n    // Subscribe to Supabase broadcast for cross-device events\r\n    let channel: ReturnType<typeof supabase.channel> | null = null;\r\n\r\n    if (isSupabaseConfigured) {\r\n        channel = supabase\r\n            .channel('activity-broadcast')\r\n            .on('broadcast', { event: 'activity' }, (payload) => {\r\n                const eventData = payload.payload as ActivityEvent & { timestamp: string };\r\n                const event: ActivityEvent = {\r\n                    ...eventData,\r\n                    timestamp: new Date(eventData.timestamp),\r\n                };\r\n\r\n                // Avoid duplicates\r\n                if (!activityLog.some(e => e.id === event.id)) {\r\n                    activityLog = [event, ...activityLog].slice(0, MAX_ACTIVITY_ITEMS);\r\n                    activityListeners.forEach(listener => listener([...activityLog]));\r\n                }\r\n            })\r\n            .subscribe();\r\n    }\r\n\r\n    // Return unsubscribe function\r\n    return () => {\r\n        activityListeners = activityListeners.filter(l => l !== onUpdate);\r\n        if (channel) {\r\n            supabase.removeChannel(channel);\r\n        }\r\n    };\r\n};\r\n\r\n// Get current activity log\r\nexport const getActivityLog = (): ActivityEvent[] => [...activityLog];\r\n\r\n// Clear activity log\r\nexport const clearActivityLog = () => {\r\n    activityLog = [];\r\n    activityListeners.forEach(listener => listener([]));\r\n};\r\n\r\n// ==========================================\r\n// ENTRY SYNC - Real-time cross-device sync\r\n// ==========================================\r\n\r\n// Sync all entries to Supabase for cross-device access\r\n// Note: Requires entries_json column in live_sessions table\r\nexport const syncEntriesToSupabase = async (\r\n    machineName: string,\r\n    shift: string,\r\n    date: string,\r\n    entries: SyncedEntries\r\n): Promise<boolean> => {\r\n    if (!isSupabaseConfigured) return false;\r\n\r\n    const sessionId = getLiveSessionId(machineName, shift, date);\r\n    const entriesJson = JSON.stringify(entries);\r\n\r\n    try {\r\n        const { error } = await supabase\r\n            .from('live_sessions')\r\n            .update({\r\n                entries_json: entriesJson,\r\n                updated_at: new Date().toISOString(),\r\n            })\r\n            .eq('id', sessionId);\r\n\r\n        if (error) {\r\n            // Silently fail if entries_json column doesn't exist yet\r\n            if (error.message.includes('entries_json') || error.message.includes('column')) {\r\n                // Column doesn't exist - sync feature not available yet\r\n                return false;\r\n            }\r\n            console.error('Failed to sync entries:', error.message);\r\n            return false;\r\n        }\r\n\r\n        console.log('ðŸ“¦ Entries synced to Supabase:', sessionId);\r\n        return true;\r\n    } catch (e) {\r\n        // Silently fail - sync feature may not be available\r\n        return false;\r\n    }\r\n};\r\n\r\n// Fetch entries from Supabase for a session\r\n// Note: Requires entries_json column in live_sessions table\r\nexport const fetchEntriesFromSupabase = async (\r\n    machineName: string,\r\n    shift: string,\r\n    date: string\r\n): Promise<SyncedEntries | null> => {\r\n    if (!isSupabaseConfigured) return null;\r\n\r\n    const sessionId = getLiveSessionId(machineName, shift, date);\r\n\r\n    try {\r\n        const { data, error } = await supabase\r\n            .from('live_sessions')\r\n            .select('entries_json')\r\n            .eq('id', sessionId)\r\n            .maybeSingle();\r\n\r\n        if (error) {\r\n            // Silently fail if entries_json column doesn't exist yet\r\n            if (error.message.includes('entries_json') || error.message.includes('column')) {\r\n                return null;\r\n            }\r\n            console.error('Failed to fetch entries:', error.message);\r\n            return null;\r\n        }\r\n\r\n        if (data?.entries_json) {\r\n            const entries = JSON.parse(data.entries_json) as SyncedEntries;\r\n            console.log('ðŸ“¦ Entries restored from Supabase:', sessionId);\r\n            return entries;\r\n        }\r\n\r\n        return null;\r\n    } catch (e) {\r\n        // Silently fail - sync feature may not be available\r\n        return null;\r\n    }\r\n};\r\n\r\n// Subscribe to entry changes for real-time sync\r\nexport const subscribeToEntryChanges = (\r\n    machineName: string,\r\n    shift: string,\r\n    date: string,\r\n    onEntriesUpdate: (entries: SyncedEntries) => void\r\n) => {\r\n    if (!isSupabaseConfigured) {\r\n        return () => { }; // No-op unsubscribe\r\n    }\r\n\r\n    const sessionId = getLiveSessionId(machineName, shift, date);\r\n\r\n    const channel = supabase\r\n        .channel(`entries-${sessionId}`)\r\n        .on(\r\n            'postgres_changes',\r\n            {\r\n                event: 'UPDATE',\r\n                schema: 'public',\r\n                table: 'live_sessions',\r\n                filter: `id=eq.${sessionId}`\r\n            },\r\n            (payload) => {\r\n                const newData = payload.new as { entries_json?: string };\r\n                if (newData.entries_json) {\r\n                    try {\r\n                        const entries = JSON.parse(newData.entries_json) as SyncedEntries;\r\n                        console.log('ðŸ”„ Real-time entries update received:', sessionId);\r\n                        onEntriesUpdate(entries);\r\n                    } catch (e) {\r\n                        console.error('Failed to parse entries update:', e);\r\n                    }\r\n                }\r\n            }\r\n        )\r\n        .subscribe((status) => {\r\n            console.log('ðŸ“¡ Entry sync subscription status:', status, sessionId);\r\n        });\r\n\r\n    return () => {\r\n        supabase.removeChannel(channel);\r\n    };\r\n};\r\n\r\n// Helper to safely convert timestamp to ISO string\r\nconst toISOString = (timestamp: Date | string): string => {\r\n    if (typeof timestamp === 'string') return timestamp;\r\n    if (timestamp instanceof Date) return timestamp.toISOString();\r\n    return new Date(timestamp).toISOString();\r\n};\r\n\r\n// Helper to convert local entries to synced format\r\nexport const convertToSyncedEntries = (\r\n    wasteEntries: { id: string; waste: number; wasteType: string; timestamp: Date | string }[],\r\n    downtimeEntries: { id: string; downtime: number; downtimeReason: string; timestamp: Date | string }[],\r\n    speedEntries: { id: string; speed: number; timestamp: Date | string }[],\r\n    sachetMassEntries: { id: string; mass: number; timestamp: Date | string }[],\r\n    looseCasesEntries: { id: string; batchNumber: string; cases: number; timestamp: Date | string }[],\r\n    palletScanEntries: { id: string; qrCode: string; batchNumber: string; palletNumber: string; casesCount: number; timestamp: Date | string; ignored?: boolean }[]\r\n): SyncedEntries => {\r\n    return {\r\n        wasteEntries: wasteEntries.map(e => ({\r\n            id: e.id,\r\n            waste: e.waste,\r\n            wasteType: e.wasteType,\r\n            timestamp: toISOString(e.timestamp),\r\n        })),\r\n        downtimeEntries: downtimeEntries.map(e => ({\r\n            id: e.id,\r\n            downtime: e.downtime,\r\n            downtimeReason: e.downtimeReason,\r\n            timestamp: toISOString(e.timestamp),\r\n        })),\r\n        speedEntries: speedEntries.map(e => ({\r\n            id: e.id,\r\n            speed: e.speed,\r\n            timestamp: toISOString(e.timestamp),\r\n        })),\r\n        sachetMassEntries: sachetMassEntries.map(e => ({\r\n            id: e.id,\r\n            mass: e.mass,\r\n            timestamp: toISOString(e.timestamp),\r\n        })),\r\n        looseCasesEntries: looseCasesEntries.map(e => ({\r\n            id: e.id,\r\n            batchNumber: e.batchNumber,\r\n            cases: e.cases,\r\n            timestamp: toISOString(e.timestamp),\r\n        })),\r\n        palletScanEntries: palletScanEntries.map(e => ({\r\n            id: e.id,\r\n            qrCode: e.qrCode,\r\n            batchNumber: e.batchNumber,\r\n            palletNumber: e.palletNumber,\r\n            casesCount: e.casesCount,\r\n            timestamp: toISOString(e.timestamp),\r\n            ignored: e.ignored,\r\n        })),\r\n    };\r\n};\r\n\r\n// Helper to convert synced entries back to local format\r\nexport const convertFromSyncedEntries = (synced: SyncedEntries) => {\r\n    return {\r\n        wasteEntries: synced.wasteEntries.map(e => ({\r\n            id: e.id,\r\n            waste: e.waste,\r\n            wasteType: e.wasteType,\r\n            timestamp: new Date(e.timestamp),\r\n        })),\r\n        downtimeEntries: synced.downtimeEntries.map(e => ({\r\n            id: e.id,\r\n            downtime: e.downtime,\r\n            downtimeReason: e.downtimeReason,\r\n            timestamp: new Date(e.timestamp),\r\n        })),\r\n        speedEntries: synced.speedEntries.map(e => ({\r\n            id: e.id,\r\n            speed: e.speed,\r\n            timestamp: new Date(e.timestamp),\r\n        })),\r\n        sachetMassEntries: synced.sachetMassEntries.map(e => ({\r\n            id: e.id,\r\n            mass: e.mass,\r\n            timestamp: new Date(e.timestamp),\r\n        })),\r\n        looseCasesEntries: synced.looseCasesEntries.map(e => ({\r\n            id: e.id,\r\n            batchNumber: e.batchNumber,\r\n            cases: e.cases,\r\n            timestamp: new Date(e.timestamp),\r\n        })),\r\n        palletScanEntries: synced.palletScanEntries.map(e => ({\r\n            id: e.id,\r\n            qrCode: e.qrCode,\r\n            batchNumber: e.batchNumber,\r\n            palletNumber: e.palletNumber,\r\n            casesCount: e.casesCount,\r\n            timestamp: new Date(e.timestamp),\r\n            ignored: e.ignored,\r\n        })),\r\n    };\r\n};\r\n\r\n// ==========================================\r\n// CURRENT MACHINE ORDER - Persists across shifts\r\n// ==========================================\r\n\r\nexport interface CurrentMachineOrder {\r\n    machine_name: string;\r\n    order_number: string;\r\n    product: string;\r\n    batch_number: string;\r\n    updated_at: string;\r\n}\r\n\r\n// Save the current order for a machine (persists across shifts)\r\nexport const saveCurrentMachineOrder = async (\r\n    machineName: string,\r\n    orderNumber: string,\r\n    product: string,\r\n    batchNumber: string\r\n): Promise<boolean> => {\r\n    // Save to localStorage as fallback\r\n    const key = `current_machine_order_${machineName}`;\r\n    const order: CurrentMachineOrder = {\r\n        machine_name: machineName,\r\n        order_number: orderNumber,\r\n        product: product,\r\n        batch_number: batchNumber,\r\n        updated_at: new Date().toISOString(),\r\n    };\r\n    localStorage.setItem(key, JSON.stringify(order));\r\n\r\n    // Try to sync to Supabase\r\n    if (isSupabaseConfigured) {\r\n        try {\r\n            const { error } = await supabase\r\n                .from('current_machine_orders')\r\n                .upsert({\r\n                    machine_name: machineName,\r\n                    order_number: orderNumber,\r\n                    product: product,\r\n                    batch_number: batchNumber,\r\n                    updated_at: new Date().toISOString(),\r\n                }, { onConflict: 'machine_name' });\r\n\r\n            if (error) {\r\n                // Table might not exist - that's ok, localStorage is the fallback\r\n                console.log('Current order saved to localStorage (Supabase table may not exist)');\r\n                return true;\r\n            }\r\n            console.log('âœ… Current machine order synced to Supabase:', machineName);\r\n        } catch (e) {\r\n            // Silently continue - localStorage has the data\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\n// Fetch the current order for a machine\r\nexport const fetchCurrentMachineOrder = async (\r\n    machineName: string\r\n): Promise<CurrentMachineOrder | null> => {\r\n    // Try Supabase first\r\n    if (isSupabaseConfigured) {\r\n        try {\r\n            const { data, error } = await supabase\r\n                .from('current_machine_orders')\r\n                .select('*')\r\n                .eq('machine_name', machineName)\r\n                .maybeSingle();\r\n\r\n            if (!error && data) {\r\n                console.log('ðŸ“‹ Current machine order loaded from Supabase:', machineName);\r\n                return data;\r\n            }\r\n        } catch (e) {\r\n            // Fall through to localStorage\r\n        }\r\n    }\r\n\r\n    // Fallback to localStorage\r\n    const key = `current_machine_order_${machineName}`;\r\n    const saved = localStorage.getItem(key);\r\n    if (saved) {\r\n        try {\r\n            const order = JSON.parse(saved) as CurrentMachineOrder;\r\n            console.log('ðŸ“‹ Current machine order loaded from localStorage:', machineName);\r\n            return order;\r\n        } catch (e) {\r\n            // Invalid data\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\n// Clear the current order for a machine (on changeover)\r\nexport const clearCurrentMachineOrder = async (machineName: string): Promise<void> => {\r\n    // Clear localStorage\r\n    const key = `current_machine_order_${machineName}`;\r\n    localStorage.removeItem(key);\r\n\r\n    // Try to clear from Supabase\r\n    if (isSupabaseConfigured) {\r\n        try {\r\n            await supabase\r\n                .from('current_machine_orders')\r\n                .delete()\r\n                .eq('machine_name', machineName);\r\n        } catch (e) {\r\n            // Silently continue\r\n        }\r\n    }\r\n};\r\n","export interface WasteEntry {\r\n  id: string;\r\n  waste: number;\r\n  wasteType: string;\r\n  timestamp: Date;\r\n}\r\n\r\nexport interface DowntimeEntry {\r\n  id: string;\r\n  downtime: number;\r\n  downtimeReason: string;\r\n  notes?: string;\r\n  timestamp: Date;\r\n}\r\n\r\n// Production timer state for tracking run time and pauses\r\nexport interface ProductionState {\r\n  isRunning: boolean;\r\n  startTime: Date | null;       // When production started\r\n  pausedAt: Date | null;        // When current pause began\r\n  totalRunTimeMs: number;       // Accumulated run time in milliseconds\r\n  lastResumedAt: Date | null;   // When last resumed from pause\r\n}\r\n\r\nexport interface SpeedEntry {\r\n  id: string;\r\n  speed: number;\r\n  timestamp: Date;\r\n}\r\n\r\nexport interface SachetMassEntry {\r\n  id: string;\r\n  mass: number; // in grams\r\n  timestamp: Date;\r\n  ignored?: boolean; // Can be set to ignore but not deleted\r\n}\r\n\r\n// Loose cases entry - for cases not part of a full pallet\r\nexport interface LooseCasesEntry {\r\n  id: string;\r\n  batchNumber: string; // 5-digit batch number\r\n  cases: number; // number of loose cases\r\n  timestamp: Date;\r\n  ignored?: boolean;\r\n}\r\n\r\n// Pallet Scan entry - QR code is 13 digits: BBBBBPPPPCCCC\r\n// B = batch number (5 digits), P = pallet number (4 digits), C = cases count (4 digits)\r\nexport interface PalletScanEntry {\r\n  id: string;\r\n  qrCode: string; // Full 13-digit QR code\r\n  batchNumber: string; // Extracted: first 5 digits\r\n  palletNumber: string; // Extracted: digits 6-9 (4 digits)\r\n  casesCount: number; // Extracted: last 4 digits\r\n  timestamp: Date;\r\n  ignored?: boolean;\r\n}\r\n\r\n// Legacy CasesPerHourEntry - kept for backwards compatibility\r\nexport interface CasesPerHourEntry {\r\n  id: string;\r\n  cases: number;\r\n  hour: number;\r\n  timestamp: Date;\r\n  ignored?: boolean;\r\n}\r\n\r\nexport interface ShiftData {\r\n  id: string;\r\n  operatorName: string;\r\n  machine: string;\r\n  subMachine?: string; // For machines that are groups (e.g., \"Universal 2 - Machine 1\")\r\n  orderNumber: string;\r\n  product: string;\r\n  batchNumber: string;\r\n  shift: string;\r\n  date: string;\r\n  wasteEntries: WasteEntry[];\r\n  downtimeEntries: DowntimeEntry[];\r\n  speedEntries?: SpeedEntry[];\r\n  sachetMassEntries?: SachetMassEntry[];\r\n  casesPerHourEntries?: CasesPerHourEntry[]; // Legacy - kept for backwards compatibility\r\n  looseCasesEntries?: LooseCasesEntry[]; // New: loose cases with batch number\r\n  palletScanEntries?: PalletScanEntry[];\r\n  submittedAt: Date;\r\n  totalWaste: number;\r\n  totalDowntime: number;\r\n}\r\n\r\nexport interface ShiftSession {\r\n  machineName: string;\r\n  operatorName: string;\r\n  orderNumber: string;\r\n  product: string;\r\n  batchNumber: string;\r\n  shift: string;\r\n  date: string;\r\n  locked: boolean; // Once set, these values are locked for the shift\r\n  // Entry data persisted with session\r\n  wasteEntries?: WasteEntry[];\r\n  downtimeEntries?: DowntimeEntry[];\r\n  speedEntries?: SpeedEntry[];\r\n  sachetMassEntries?: SachetMassEntry[];\r\n  casesPerHourEntries?: CasesPerHourEntry[]; // Legacy\r\n  looseCasesEntries?: LooseCasesEntry[]; // New\r\n  palletScanEntries?: PalletScanEntry[];\r\n}\r\n\r\nexport interface Machine {\r\n  id: string;\r\n  name: string;\r\n  status: 'running' | 'idle' | 'maintenance';\r\n  currentOperator?: string;\r\n  currentOrder?: string;\r\n  currentShift?: string;\r\n  lastSubmission?: string;\r\n  todayWaste?: number;\r\n  todayDowntime?: number;\r\n  subMachineCount?: number; // Number of sub-machines (e.g., 4 for \"Universal 2\")\r\n}\r\n\r\n// ==============================================\r\n// DEFAULT DATA\r\n// ==============================================\r\n\r\nexport const OPERATORS: string[] = [];\r\nexport const MACHINES: Machine[] = [];\r\n\r\n// Waste Types - common manufacturing waste categories\r\nexport const WASTE_TYPES: string[] = [\r\n  'Start-up Waste',\r\n  'Changeover Waste',\r\n  'Defective Product',\r\n  'Material Spillage',\r\n];\r\n\r\n// Downtime Reasons - categorized by planned vs unplanned\r\nexport const PLANNED_DOWNTIME_REASONS: string[] = [\r\n  'Scheduled Maintenance',\r\n  'Changeover',\r\n];\r\n\r\nexport const UNPLANNED_DOWNTIME_REASONS: string[] = [\r\n  'Machine Breakdown',\r\n  'Material Shortage',\r\n];\r\n\r\n// Combined downtime reasons for selection\r\nexport const DOWNTIME_REASONS: string[] = [\r\n  'Machine Breakdown',\r\n  'Scheduled Maintenance',\r\n  'Changeover',\r\n  'Material Shortage',\r\n];\r\n\r\nexport const ORDER_NUMBERS: string[] = [];\r\nexport const PRODUCTS: string[] = [];\r\nexport const BATCH_NUMBERS: string[] = [];\r\n\r\n","import { ShiftData, Machine, MACHINES } from '../types';\r\nimport {\r\n  fetchMachines,\r\n  upsertMachine,\r\n  removeMachine,\r\n  syncMachinesToSupabase,\r\n  subscribeMachineChanges,\r\n  MachineRecord,\r\n  submitShiftData,\r\n  isSupabaseConfigured\r\n} from './supabase';\r\n\r\nconst STORAGE_KEY = 'waste_downtime_history';\r\nconst MACHINES_KEY = 'machines_data';\r\nconst MACHINES_SYNC_KEY = 'machines_last_sync';\r\nconst FAILED_SUBMISSIONS_KEY = 'failed_submissions_queue';\r\nconst HISTORY_MAX_DAYS = 90; // Keep history for 90 days\r\nconst HISTORY_MAX_ENTRIES = 1000; // Maximum entries to keep\r\n\r\n// ==========================================\r\n// FAILED SUBMISSIONS RETRY QUEUE\r\n// ==========================================\r\n\r\ninterface FailedSubmission {\r\n  id: string;\r\n  timestamp: string;\r\n  retryCount: number;\r\n  maxRetries: number;\r\n  data: {\r\n    shiftData: any;\r\n    wasteEntries: any[];\r\n    downtimeEntries: any[];\r\n    speedEntries?: any[];\r\n    sachetMassEntries?: any[];\r\n    looseCasesEntries?: any[];\r\n    palletScanEntries?: any[];\r\n  };\r\n  error: string;\r\n}\r\n\r\n// Get failed submissions queue\r\nexport const getFailedSubmissions = (): FailedSubmission[] => {\r\n  const stored = localStorage.getItem(FAILED_SUBMISSIONS_KEY);\r\n  if (!stored) return [];\r\n  try {\r\n    return JSON.parse(stored);\r\n  } catch {\r\n    return [];\r\n  }\r\n};\r\n\r\n// Add a failed submission to the retry queue\r\nexport const addFailedSubmission = (\r\n  data: FailedSubmission['data'],\r\n  error: string\r\n): void => {\r\n  const queue = getFailedSubmissions();\r\n  const newEntry: FailedSubmission = {\r\n    id: `failed_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n    timestamp: new Date().toISOString(),\r\n    retryCount: 0,\r\n    maxRetries: 3,\r\n    data,\r\n    error,\r\n  };\r\n  queue.push(newEntry);\r\n  localStorage.setItem(FAILED_SUBMISSIONS_KEY, JSON.stringify(queue));\r\n};\r\n\r\n// Remove a submission from the failed queue\r\nexport const removeFailedSubmission = (id: string): void => {\r\n  const queue = getFailedSubmissions();\r\n  const filtered = queue.filter(s => s.id !== id);\r\n  localStorage.setItem(FAILED_SUBMISSIONS_KEY, JSON.stringify(filtered));\r\n};\r\n\r\n// Retry all failed submissions\r\nexport const retryFailedSubmissions = async (): Promise<{\r\n  succeeded: number;\r\n  failed: number;\r\n  remaining: number;\r\n}> => {\r\n  if (!isSupabaseConfigured) {\r\n    return { succeeded: 0, failed: 0, remaining: getFailedSubmissions().length };\r\n  }\r\n\r\n  const queue = getFailedSubmissions();\r\n  let succeeded = 0;\r\n  let failed = 0;\r\n\r\n  for (const submission of queue) {\r\n    if (submission.retryCount >= submission.maxRetries) {\r\n      // Max retries reached, keep in queue but don't retry\r\n      failed++;\r\n      continue;\r\n    }\r\n\r\n    try {\r\n      await submitShiftData(\r\n        submission.data.shiftData,\r\n        submission.data.wasteEntries,\r\n        submission.data.downtimeEntries,\r\n        submission.data.speedEntries,\r\n        submission.data.sachetMassEntries,\r\n        submission.data.looseCasesEntries,\r\n        submission.data.palletScanEntries\r\n      );\r\n      removeFailedSubmission(submission.id);\r\n      succeeded++;\r\n    } catch (e) {\r\n      // Update retry count\r\n      const updatedQueue = getFailedSubmissions().map(s =>\r\n        s.id === submission.id\r\n          ? { ...s, retryCount: s.retryCount + 1, error: String(e) }\r\n          : s\r\n      );\r\n      localStorage.setItem(FAILED_SUBMISSIONS_KEY, JSON.stringify(updatedQueue));\r\n      failed++;\r\n    }\r\n  }\r\n\r\n  return {\r\n    succeeded,\r\n    failed,\r\n    remaining: getFailedSubmissions().length,\r\n  };\r\n};\r\n\r\n// Clear all failed submissions (manual clear)\r\nexport const clearFailedSubmissions = (): void => {\r\n  localStorage.removeItem(FAILED_SUBMISSIONS_KEY);\r\n};\r\n\r\n// ==========================================\r\n// LOCALSTORAGE CLEANUP\r\n// ==========================================\r\n\r\n// Clean up old history entries\r\nexport const cleanupOldHistory = (): { removed: number; remaining: number } => {\r\n  const history = getShiftHistory();\r\n  const now = new Date();\r\n  const cutoffDate = new Date(now.getTime() - HISTORY_MAX_DAYS * 24 * 60 * 60 * 1000);\r\n\r\n  // Filter out entries older than cutoff date\r\n  let cleaned = history.filter(item => {\r\n    const itemDate = new Date(item.date);\r\n    return itemDate >= cutoffDate;\r\n  });\r\n\r\n  // Also limit to max entries (keep most recent)\r\n  if (cleaned.length > HISTORY_MAX_ENTRIES) {\r\n    cleaned = cleaned.slice(0, HISTORY_MAX_ENTRIES);\r\n  }\r\n\r\n  const removed = history.length - cleaned.length;\r\n\r\n  if (removed > 0) {\r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(cleaned));\r\n    console.log(`Cleaned up ${removed} old history entries`);\r\n  }\r\n\r\n  return { removed, remaining: cleaned.length };\r\n};\r\n\r\n// Get localStorage usage stats\r\nexport const getStorageStats = (): {\r\n  historyCount: number;\r\n  failedCount: number;\r\n  totalSizeKB: number;\r\n  oldestEntry: string | null;\r\n} => {\r\n  const history = getShiftHistory();\r\n  const failed = getFailedSubmissions();\r\n\r\n  // Estimate total localStorage size\r\n  let totalSize = 0;\r\n  for (let i = 0; i < localStorage.length; i++) {\r\n    const key = localStorage.key(i);\r\n    if (key) {\r\n      const value = localStorage.getItem(key) || '';\r\n      totalSize += key.length + value.length;\r\n    }\r\n  }\r\n\r\n  const oldestEntry = history.length > 0\r\n    ? history[history.length - 1].date\r\n    : null;\r\n\r\n  return {\r\n    historyCount: history.length,\r\n    failedCount: failed.length,\r\n    totalSizeKB: Math.round(totalSize / 1024),\r\n    oldestEntry,\r\n  };\r\n};\r\n\r\n// Run cleanup on app startup (debounced to run once per day)\r\nexport const maybeRunCleanup = (): void => {\r\n  const lastCleanupKey = 'last_storage_cleanup';\r\n  const lastCleanup = localStorage.getItem(lastCleanupKey);\r\n  const now = new Date();\r\n\r\n  if (lastCleanup) {\r\n    const lastDate = new Date(lastCleanup);\r\n    const hoursSinceCleanup = (now.getTime() - lastDate.getTime()) / (1000 * 60 * 60);\r\n    if (hoursSinceCleanup < 24) {\r\n      return; // Already cleaned up today\r\n    }\r\n  }\r\n\r\n  // Run cleanup\r\n  const result = cleanupOldHistory();\r\n  localStorage.setItem(lastCleanupKey, now.toISOString());\r\n\r\n  if (result.removed > 0) {\r\n    console.log(`Storage cleanup: removed ${result.removed} entries, ${result.remaining} remaining`);\r\n  }\r\n};\r\n\r\n// Flag to track if we're using Supabase\r\nlet useSupabase = true;\r\nlet machinesCache: Machine[] | null = null;\r\nlet machinesListeners: ((machines: Machine[]) => void)[] = [];\r\n\r\n// Convert Supabase record to local Machine type\r\nconst toLocalMachine = (record: MachineRecord): Machine => ({\r\n  id: record.id,\r\n  name: record.name,\r\n  status: record.status,\r\n  currentOperator: record.current_operator,\r\n  currentOrder: record.current_order,\r\n  currentShift: record.current_shift,\r\n  lastSubmission: record.last_submission,\r\n  todayWaste: record.today_waste,\r\n  todayDowntime: record.today_downtime,\r\n  subMachineCount: record.sub_machine_count,\r\n});\r\n\r\n// Convert local Machine to Supabase record\r\nconst toSupabaseRecord = (machine: Machine): MachineRecord => ({\r\n  id: machine.id,\r\n  name: machine.name,\r\n  status: machine.status,\r\n  current_operator: machine.currentOperator,\r\n  current_order: machine.currentOrder,\r\n  current_shift: machine.currentShift,\r\n  last_submission: machine.lastSubmission,\r\n  today_waste: machine.todayWaste,\r\n  today_downtime: machine.todayDowntime,\r\n  sub_machine_count: machine.subMachineCount,\r\n});\r\n\r\n// Initialize machines from Supabase\r\nexport const initializeMachines = async (): Promise<Machine[]> => {\r\n  try {\r\n    const records = await fetchMachines();\r\n\r\n    if (records.length > 0) {\r\n      machinesCache = records.map(toLocalMachine);\r\n      // Also save to localStorage as backup\r\n      localStorage.setItem(MACHINES_KEY, JSON.stringify(machinesCache));\r\n      localStorage.setItem(MACHINES_SYNC_KEY, new Date().toISOString());\r\n      return machinesCache;\r\n    } else {\r\n      // No machines in Supabase, sync default machines\r\n      console.log('No machines in Supabase, syncing defaults...');\r\n      const defaultMachines = MACHINES.map(toSupabaseRecord);\r\n      await syncMachinesToSupabase(defaultMachines);\r\n      machinesCache = MACHINES;\r\n      localStorage.setItem(MACHINES_KEY, JSON.stringify(MACHINES));\r\n      return MACHINES;\r\n    }\r\n  } catch (error) {\r\n    console.error('Failed to initialize from Supabase, using localStorage:', error);\r\n    useSupabase = false;\r\n    return getMachinesDataLocal();\r\n  }\r\n};\r\n\r\n// Subscribe to real-time machine updates - OPTIMIZED\r\nexport const subscribeToMachineUpdates = (callback: (machines: Machine[]) => void) => {\r\n  machinesListeners.push(callback);\r\n\r\n  // Provide current machines getter for optimized real-time updates\r\n  const getCurrentMachines = (): MachineRecord[] => {\r\n    const current = machinesCache || getMachinesDataLocal();\r\n    return current.map(toSupabaseRecord);\r\n  };\r\n\r\n  // Set up Supabase real-time subscription with optimized handler\r\n  const unsubscribe = subscribeMachineChanges(\r\n    (records) => {\r\n      machinesCache = records.map(toLocalMachine);\r\n      localStorage.setItem(MACHINES_KEY, JSON.stringify(machinesCache));\r\n\r\n      // Notify all listeners\r\n      machinesListeners.forEach(listener => listener(machinesCache!));\r\n    },\r\n    getCurrentMachines\r\n  );\r\n\r\n  // Return cleanup function\r\n  return () => {\r\n    machinesListeners = machinesListeners.filter(l => l !== callback);\r\n    if (machinesListeners.length === 0) {\r\n      unsubscribe();\r\n    }\r\n  };\r\n};\r\n\r\n// Get machines from localStorage (fallback)\r\nconst getMachinesDataLocal = (): Machine[] => {\r\n  const stored = localStorage.getItem(MACHINES_KEY);\r\n  if (!stored) {\r\n    localStorage.setItem(MACHINES_KEY, JSON.stringify(MACHINES));\r\n    return MACHINES;\r\n  }\r\n\r\n  try {\r\n    return JSON.parse(stored);\r\n  } catch {\r\n    return MACHINES;\r\n  }\r\n};\r\n\r\n// Save shift data to local storage\r\nexport const saveShiftData = (data: ShiftData): void => {\r\n  const existing = getShiftHistory();\r\n  existing.unshift(data);\r\n  localStorage.setItem(STORAGE_KEY, JSON.stringify(existing));\r\n\r\n  // Update machine data\r\n  updateMachineLastSubmission(data.machine, data.submittedAt.toISOString());\r\n};\r\n\r\n// Get all shift history\r\nexport const getShiftHistory = (): ShiftData[] => {\r\n  const stored = localStorage.getItem(STORAGE_KEY);\r\n  if (!stored) return [];\r\n\r\n  try {\r\n    const parsed = JSON.parse(stored);\r\n    return parsed.map((item: any) => ({\r\n      ...item,\r\n      submittedAt: new Date(item.submittedAt),\r\n      wasteEntries: item.wasteEntries.map((w: any) => ({\r\n        ...w,\r\n        timestamp: new Date(w.timestamp),\r\n      })),\r\n      downtimeEntries: item.downtimeEntries.map((d: any) => ({\r\n        ...d,\r\n        timestamp: new Date(d.timestamp),\r\n      })),\r\n    }));\r\n  } catch {\r\n    return [];\r\n  }\r\n};\r\n\r\n// Get shift history for a specific date range\r\nexport const getShiftHistoryByDateRange = (startDate: Date, endDate: Date): ShiftData[] => {\r\n  const history = getShiftHistory();\r\n  return history.filter(item => {\r\n    const itemDate = new Date(item.date);\r\n    return itemDate >= startDate && itemDate <= endDate;\r\n  });\r\n};\r\n\r\n// Get shift history for a specific machine\r\nexport const getShiftHistoryByMachine = (machineName: string): ShiftData[] => {\r\n  const history = getShiftHistory();\r\n  return history.filter(item => item.machine === machineName);\r\n};\r\n\r\n// Get today's statistics\r\nexport const getTodayStats = () => {\r\n  const today = new Date().toISOString().split('T')[0];\r\n  const history = getShiftHistory();\r\n  const todayData = history.filter(item => item.date === today);\r\n\r\n  const totalWaste = todayData.reduce((sum, item) => sum + item.totalWaste, 0);\r\n  const totalDowntime = todayData.reduce((sum, item) => sum + item.totalDowntime, 0);\r\n  const submissionCount = todayData.length;\r\n\r\n  return { totalWaste, totalDowntime, submissionCount };\r\n};\r\n\r\n// Update machine last submission\r\nexport const updateMachineLastSubmission = (machineName: string, timestamp: string): void => {\r\n  const machines = getMachinesData();\r\n  const machineIndex = machines.findIndex(m => m.name === machineName);\r\n  if (machineIndex !== -1) {\r\n    machines[machineIndex].lastSubmission = getTimeAgo(new Date(timestamp));\r\n  }\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(machines));\r\n};\r\n\r\n// Get machines data with local modifications\r\nexport const getMachinesData = (): Machine[] => {\r\n  // Return cache if available\r\n  if (machinesCache) {\r\n    return machinesCache;\r\n  }\r\n\r\n  // Otherwise return from localStorage\r\n  return getMachinesDataLocal();\r\n};\r\n\r\n// Update a single machine\r\nexport const updateMachine = async (machineId: string, updates: Partial<Machine>): Promise<void> => {\r\n  const machines = getMachinesData();\r\n  const index = machines.findIndex(m => m.id === machineId);\r\n  if (index !== -1) {\r\n    machines[index] = { ...machines[index], ...updates };\r\n    machinesCache = machines;\r\n    localStorage.setItem(MACHINES_KEY, JSON.stringify(machines));\r\n\r\n    // Sync to Supabase\r\n    if (useSupabase) {\r\n      try {\r\n        await upsertMachine(toSupabaseRecord(machines[index]));\r\n      } catch (error) {\r\n        console.error('Failed to sync machine update to Supabase:', error);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n// Add a new machine\r\nexport const addMachine = async (machine: Machine): Promise<void> => {\r\n  const machines = getMachinesData();\r\n  machines.push(machine);\r\n  machinesCache = machines;\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(machines));\r\n\r\n  // Sync to Supabase\r\n  if (useSupabase) {\r\n    try {\r\n      await upsertMachine(toSupabaseRecord(machine));\r\n    } catch (error) {\r\n      console.error('Failed to sync new machine to Supabase:', error);\r\n    }\r\n  }\r\n};\r\n\r\n// Delete a machine\r\nexport const deleteMachine = async (machineId: string): Promise<void> => {\r\n  const machines = getMachinesData();\r\n  const filtered = machines.filter(m => m.id !== machineId);\r\n  machinesCache = filtered;\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(filtered));\r\n\r\n  // Sync to Supabase\r\n  if (useSupabase) {\r\n    try {\r\n      await removeMachine(machineId);\r\n    } catch (error) {\r\n      console.error('Failed to delete machine from Supabase:', error);\r\n    }\r\n  }\r\n};\r\n\r\n// Reset machines to default\r\nexport const resetMachines = async (): Promise<void> => {\r\n  machinesCache = MACHINES;\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(MACHINES));\r\n\r\n  // Sync to Supabase\r\n  if (useSupabase) {\r\n    try {\r\n      await syncMachinesToSupabase(MACHINES.map(toSupabaseRecord));\r\n    } catch (error) {\r\n      console.error('Failed to reset machines in Supabase:', error);\r\n    }\r\n  }\r\n};\r\n\r\n// Helper function to format time ago\r\nexport const getTimeAgo = (date: Date): string => {\r\n  const now = new Date();\r\n  const diffMs = now.getTime() - date.getTime();\r\n  const diffMins = Math.floor(diffMs / 60000);\r\n  const diffHours = Math.floor(diffMins / 60);\r\n  const diffDays = Math.floor(diffHours / 24);\r\n\r\n  if (diffMins < 1) return 'Just now';\r\n  if (diffMins < 60) return `${diffMins} min ago`;\r\n  if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;\r\n  return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;\r\n};\r\n\r\n// Export data to CSV\r\nexport const exportToCSV = (data: ShiftData[], filename: string): void => {\r\n  const headers = [\r\n    'Date',\r\n    'Shift',\r\n    'Operator',\r\n    'Machine',\r\n    'Order Number',\r\n    'Product',\r\n    'Batch Number',\r\n    'Entry Type',\r\n    'Waste Type',\r\n    'Waste (kg)',\r\n    'Downtime Reason',\r\n    'Downtime (min)',\r\n    'Submitted At',\r\n  ];\r\n\r\n  const rows: string[][] = [];\r\n\r\n  data.forEach(item => {\r\n    const baseRow = [\r\n      item.date,\r\n      item.shift,\r\n      item.operatorName,\r\n      item.machine,\r\n      item.orderNumber,\r\n      item.product,\r\n      item.batchNumber,\r\n    ];\r\n    const submittedAt = new Date(item.submittedAt).toLocaleString();\r\n\r\n    // Add a row for each waste entry\r\n    if (item.wasteEntries && item.wasteEntries.length > 0) {\r\n      item.wasteEntries.forEach(w => {\r\n        rows.push([\r\n          ...baseRow,\r\n          'Waste',\r\n          w.wasteType,\r\n          w.waste.toFixed(2),\r\n          '',\r\n          '',\r\n          submittedAt,\r\n        ]);\r\n      });\r\n    }\r\n\r\n    // Add a row for each downtime entry\r\n    if (item.downtimeEntries && item.downtimeEntries.length > 0) {\r\n      item.downtimeEntries.forEach(d => {\r\n        rows.push([\r\n          ...baseRow,\r\n          'Downtime',\r\n          '',\r\n          '',\r\n          d.downtimeReason,\r\n          d.downtime.toString(),\r\n          submittedAt,\r\n        ]);\r\n      });\r\n    }\r\n\r\n    // If no entries at all, still add one summary row\r\n    if ((!item.wasteEntries || item.wasteEntries.length === 0) &&\r\n      (!item.downtimeEntries || item.downtimeEntries.length === 0)) {\r\n      rows.push([\r\n        ...baseRow,\r\n        'Summary',\r\n        '',\r\n        item.totalWaste.toFixed(2),\r\n        '',\r\n        item.totalDowntime.toString(),\r\n        submittedAt,\r\n      ]);\r\n    }\r\n  });\r\n\r\n  const csvContent = [\r\n    headers.join(','),\r\n    ...rows.map(row => row.map(cell => `\"${cell}\"`).join(',')),\r\n  ].join('\\n');\r\n\r\n  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\r\n  const link = document.createElement('a');\r\n  const url = URL.createObjectURL(blob);\r\n  link.setAttribute('href', url);\r\n  link.setAttribute('download', `${filename}.csv`);\r\n  link.style.visibility = 'hidden';\r\n  document.body.appendChild(link);\r\n  link.click();\r\n  document.body.removeChild(link);\r\n  // Clean up the object URL to prevent memory leak\r\n  URL.revokeObjectURL(url);\r\n};\r\n\r\n// Clear all history (for testing)\r\nexport const clearHistory = (): void => {\r\n  localStorage.removeItem(STORAGE_KEY);\r\n  localStorage.removeItem(MACHINES_KEY);\r\n};\r\n\r\n// ==========================================\r\n// SHARED LINE SPEED - Syncs across sub-machines\r\n// ==========================================\r\n\r\nconst LINE_SPEED_KEY_PREFIX = 'line_speed_';\r\n\r\n/**\r\n * Extract parent machine name from a sub-machine name\r\n * e.g., \"Cubes - Machine 1\" â†’ \"Cubes\"\r\n * e.g., \"Universal 2 - Machine 3\" â†’ \"Universal 2\"\r\n */\r\nexport const getParentMachineName = (machineName: string): string => {\r\n  // Check if it matches the pattern \"Parent - Machine N\"\r\n  const match = machineName.match(/^(.+?)\\s*-\\s*Machine\\s*\\d+$/i);\r\n  if (match) {\r\n    return match[1].trim();\r\n  }\r\n  // Return the original name if no sub-machine pattern found\r\n  return machineName;\r\n};\r\n\r\n/**\r\n * Get the storage key for shared line speed\r\n */\r\nconst getLineSpeedKey = (parentMachineName: string, shift: string, date: string): string => {\r\n  return `${LINE_SPEED_KEY_PREFIX}${parentMachineName}_${shift}_${date}`;\r\n};\r\n\r\n/**\r\n * Save shared line speed (called when any sub-machine sets speed)\r\n */\r\nexport const saveLineSpeed = (\r\n  machineName: string,\r\n  shift: string,\r\n  date: string,\r\n  speed: number\r\n): void => {\r\n  const parentName = getParentMachineName(machineName);\r\n  const key = getLineSpeedKey(parentName, shift, date);\r\n\r\n  const data = {\r\n    speed,\r\n    updatedAt: new Date().toISOString(),\r\n    updatedBy: machineName,\r\n  };\r\n\r\n  localStorage.setItem(key, JSON.stringify(data));\r\n  console.log(`ðŸ’¾ Saved line speed ${speed} PPM for ${parentName}`);\r\n};\r\n\r\n/**\r\n * Get shared line speed (returns the speed set by any sibling machine)\r\n */\r\nexport const getLineSpeed = (\r\n  machineName: string,\r\n  shift: string,\r\n  date: string\r\n): { speed: number; updatedBy: string; updatedAt: string } | null => {\r\n  const parentName = getParentMachineName(machineName);\r\n  const key = getLineSpeedKey(parentName, shift, date);\r\n\r\n  const stored = localStorage.getItem(key);\r\n  if (!stored) return null;\r\n\r\n  try {\r\n    const data = JSON.parse(stored);\r\n    console.log(`ðŸ“– Loaded line speed ${data.speed} PPM for ${parentName} (set by ${data.updatedBy})`);\r\n    return data;\r\n  } catch {\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Clear shared line speed (called when session ends)\r\n */\r\nexport const clearLineSpeed = (\r\n  machineName: string,\r\n  shift: string,\r\n  date: string\r\n): void => {\r\n  const parentName = getParentMachineName(machineName);\r\n  const key = getLineSpeedKey(parentName, shift, date);\r\n  localStorage.removeItem(key);\r\n};\r\n\r\n/**\r\n * Clean up old line speed entries (called periodically)\r\n */\r\nexport const cleanupOldLineSpeeds = (retentionDays: number = 7): number => {\r\n  const cutoff = Date.now() - (retentionDays * 24 * 60 * 60 * 1000);\r\n  let removed = 0;\r\n\r\n  for (let i = localStorage.length - 1; i >= 0; i--) {\r\n    const key = localStorage.key(i);\r\n    if (key?.startsWith(LINE_SPEED_KEY_PREFIX)) {\r\n      try {\r\n        const data = localStorage.getItem(key);\r\n        if (data) {\r\n          const parsed = JSON.parse(data);\r\n          const updatedAt = new Date(parsed.updatedAt).getTime();\r\n          if (updatedAt < cutoff) {\r\n            localStorage.removeItem(key);\r\n            removed++;\r\n          }\r\n        }\r\n      } catch {\r\n        // Invalid data - remove it\r\n        localStorage.removeItem(key);\r\n        removed++;\r\n      }\r\n    }\r\n  }\r\n\r\n  return removed;\r\n};\r\n"],"names":["getLiveSessionId","machineName","shift","date","concat","sessionsCache","Map","lastFetchTime","upsertLiveSession","async","sessionId","session","liveSession","id","machine_name","operator_name","operatorName","order_number","orderNumber","product","batch_number","batchNumber","session_date","is_locked","locked","total_waste","totalWaste","total_downtime","totalDowntime","updated_at","Date","toISOString","set","isSupabaseConfigured","error","supabase","from","upsert","onConflict","console","message","log","e","deleteLiveSession","delete","eq","fetchActiveSessions","now","today","split","shouldUseCache","data","select","Array","values","filter","s","clear","forEach","length","map","fetchLiveSessionByMachine","has","get","maybeSingle","subscribeToSessionChanges","onUpdate","channel","on","event","schema","table","payload","eventType","sessions","subscribe","status","removeChannel","activityLog","activityListeners","subscribeToActivityFeed","push","eventData","_objectSpread","timestamp","some","slice","listener","l","syncEntriesToSupabase","entries","entriesJson","JSON","stringify","update","entries_json","includes","fetchEntriesFromSupabase","parse","subscribeToEntryChanges","onEntriesUpdate","newData","new","convertToSyncedEntries","wasteEntries","downtimeEntries","speedEntries","sachetMassEntries","looseCasesEntries","palletScanEntries","waste","wasteType","downtime","downtimeReason","speed","mass","cases","qrCode","palletNumber","casesCount","ignored","convertFromSyncedEntries","synced","saveCurrentMachineOrder","key","order","localStorage","setItem","fetchCurrentMachineOrder","saved","getItem","clearCurrentMachineOrder","removeItem","MACHINES","WASTE_TYPES","DOWNTIME_REASONS","STORAGE_KEY","MACHINES_KEY","FAILED_SUBMISSIONS_KEY","getFailedSubmissions","stored","_unused","addFailedSubmission","queue","newEntry","Math","random","toString","substr","retryCount","maxRetries","removeFailedSubmission","filtered","retryFailedSubmissions","succeeded","failed","remaining","submission","submitShiftData","shiftData","updatedQueue","String","maybeRunCleanup","lastCleanupKey","lastCleanup","lastDate","getTime","result","cleanupOldHistory","history","getShiftHistory","cutoffDate","HISTORY_MAX_DAYS","cleaned","item","removed","useSupabase","machinesCache","machinesListeners","toLocalMachine","record","name","currentOperator","current_operator","currentOrder","current_order","currentShift","current_shift","lastSubmission","last_submission","todayWaste","today_waste","todayDowntime","today_downtime","subMachineCount","sub_machine_count","toSupabaseRecord","machine","initializeMachines","records","fetchMachines","defaultMachines","syncMachinesToSupabase","getMachinesDataLocal","subscribeToMachineUpdates","callback","unsubscribe","subscribeMachineChanges","getCurrentMachines","_unused2","saveShiftData","existing","unshift","updateMachineLastSubmission","submittedAt","w","d","_unused3","getTodayStats","todayData","reduce","sum","submissionCount","machines","getMachinesData","machineIndex","findIndex","m","getTimeAgo","updateMachine","machineId","updates","index","upsertMachine","addMachine","deleteMachine","removeMachine","diffMs","diffMins","floor","diffHours","diffDays","exportToCSV","filename","rows","baseRow","toLocaleString","toFixed","csvContent","join","row","cell","blob","Blob","type","link","document","createElement","url","URL","createObjectURL","setAttribute","style","visibility","body","appendChild","click","removeChild","revokeObjectURL","LINE_SPEED_KEY_PREFIX","getParentMachineName","match","trim","getLineSpeedKey","parentMachineName","saveLineSpeed","parentName","updatedAt","updatedBy","getLineSpeed","_unused4"],"ignoreList":[],"sourceRoot":""}