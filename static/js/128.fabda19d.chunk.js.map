{"version":3,"file":"static/js/128.fabda19d.chunk.js","mappings":"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","sources":["lib/liveSession.ts","types.ts","lib/storage.ts"],"sourcesContent":["import { supabase, isSupabaseConfigured } from './supabase';\r\n\r\n// ==========================================\r\n// LIVE SESSIONS - Cross-device sync with offline fallback\r\n// ==========================================\r\n\r\nexport interface LiveSession {\r\n    id: string; // Format: \"machineName_shift_date\"\r\n    machine_name: string;\r\n    operator_name: string;\r\n    order_number: string;\r\n    product: string;\r\n    batch_number: string;\r\n    shift: string;\r\n    session_date: string;\r\n    is_locked: boolean;\r\n    total_waste?: number;\r\n    total_downtime?: number;\r\n    // JSON-encoded entries for cross-device sync\r\n    entries_json?: string;\r\n    created_at?: string;\r\n    updated_at?: string;\r\n}\r\n\r\n// Entry types for cross-device sync\r\nexport interface SyncedWasteEntry {\r\n    id: string;\r\n    waste: number;\r\n    wasteType: string;\r\n    timestamp: string;\r\n}\r\n\r\nexport interface SyncedDowntimeEntry {\r\n    id: string;\r\n    downtime: number;\r\n    downtimeReason: string;\r\n    timestamp: string;\r\n}\r\n\r\nexport interface SyncedSpeedEntry {\r\n    id: string;\r\n    speed: number;\r\n    timestamp: string;\r\n}\r\n\r\nexport interface SyncedSachetMassEntry {\r\n    id: string;\r\n    mass: number;\r\n    timestamp: string;\r\n}\r\n\r\nexport interface SyncedLooseCasesEntry {\r\n    id: string;\r\n    batchNumber: string;\r\n    cases: number;\r\n    timestamp: string;\r\n}\r\n\r\nexport interface SyncedPalletScanEntry {\r\n    id: string;\r\n    qrCode: string;\r\n    batchNumber: string;\r\n    palletNumber: string;\r\n    casesCount: number;\r\n    timestamp: string;\r\n    ignored?: boolean;\r\n}\r\n\r\nexport interface SyncedEntries {\r\n    wasteEntries: SyncedWasteEntry[];\r\n    downtimeEntries: SyncedDowntimeEntry[];\r\n    speedEntries: SyncedSpeedEntry[];\r\n    sachetMassEntries: SyncedSachetMassEntry[];\r\n    looseCasesEntries: SyncedLooseCasesEntry[];\r\n    palletScanEntries: SyncedPalletScanEntry[];\r\n}\r\n\r\n// Generate session ID from components\r\nexport const getLiveSessionId = (machineName: string, shift: string, date: string): string => {\r\n    return `${machineName}_${shift}_${date}`;\r\n};\r\n\r\n// Cache for active sessions (used when offline or for quick lookups)\r\nlet sessionsCache: Map<string, LiveSession> = new Map();\r\nlet lastFetchTime: number = 0;\r\nconst CACHE_TTL_MS = 30000; // 30 seconds cache\r\n\r\n// ==========================================\r\n// UPSERT SESSION (Save/Update)\r\n// ==========================================\r\nexport const upsertLiveSession = async (session: {\r\n    machineName: string;\r\n    operatorName: string;\r\n    orderNumber: string;\r\n    product: string;\r\n    batchNumber: string;\r\n    shift: string;\r\n    date: string;\r\n    locked: boolean;\r\n    totalWaste?: number;\r\n    totalDowntime?: number;\r\n}): Promise<boolean> => {\r\n    const sessionId = getLiveSessionId(session.machineName, session.shift, session.date);\r\n\r\n    const liveSession: LiveSession = {\r\n        id: sessionId,\r\n        machine_name: session.machineName,\r\n        operator_name: session.operatorName,\r\n        order_number: session.orderNumber,\r\n        product: session.product,\r\n        batch_number: session.batchNumber,\r\n        shift: session.shift,\r\n        session_date: session.date,\r\n        is_locked: session.locked,\r\n        total_waste: session.totalWaste || 0,\r\n        total_downtime: session.totalDowntime || 0,\r\n        updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    // Always update local cache first\r\n    sessionsCache.set(sessionId, liveSession);\r\n\r\n    // Try to sync to Supabase\r\n    if (isSupabaseConfigured) {\r\n        try {\r\n            const { error } = await supabase\r\n                .from('live_sessions')\r\n                .upsert({\r\n                    id: sessionId,\r\n                    machine_name: session.machineName,\r\n                    operator_name: session.operatorName,\r\n                    order_number: session.orderNumber,\r\n                    product: session.product,\r\n                    batch_number: session.batchNumber,\r\n                    shift: session.shift,\r\n                    session_date: session.date,\r\n                    is_locked: session.locked,\r\n                    total_waste: session.totalWaste || 0,\r\n                    total_downtime: session.totalDowntime || 0,\r\n                    updated_at: new Date().toISOString(),\r\n                }, { onConflict: 'id' });\r\n\r\n            if (error) {\r\n                console.error('Failed to upsert live session:', error.message);\r\n                return false;\r\n            }\r\n            console.log('âœ… Live session synced to Supabase:', sessionId);\r\n            return true;\r\n        } catch (e) {\r\n            console.error('Failed to upsert live session:', e);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Offline - cached locally, will sync later\r\n    return true;\r\n};\r\n\r\n// ==========================================\r\n// DELETE SESSION (When submitted or cleared)\r\n// ==========================================\r\nexport const deleteLiveSession = async (\r\n    machineName: string,\r\n    shift: string,\r\n    date: string\r\n): Promise<boolean> => {\r\n    const sessionId = getLiveSessionId(machineName, shift, date);\r\n\r\n    // Remove from local cache\r\n    sessionsCache.delete(sessionId);\r\n\r\n    // Try to delete from Supabase\r\n    if (isSupabaseConfigured) {\r\n        try {\r\n            const { error } = await supabase\r\n                .from('live_sessions')\r\n                .delete()\r\n                .eq('id', sessionId);\r\n\r\n            if (error) {\r\n                console.error('Failed to delete live session:', error.message);\r\n                return false;\r\n            }\r\n            return true;\r\n        } catch (e) {\r\n            console.error('Failed to delete live session:', e);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\n// ==========================================\r\n// FETCH ACTIVE SESSIONS (For Dashboard)\r\n// ==========================================\r\nexport const fetchActiveSessions = async (): Promise<LiveSession[]> => {\r\n    const now = Date.now();\r\n    const today = new Date().toISOString().split('T')[0];\r\n\r\n    // Return cache if fresh and online fetch fails\r\n    const shouldUseCache = now - lastFetchTime < CACHE_TTL_MS;\r\n\r\n    if (isSupabaseConfigured) {\r\n        try {\r\n            const { data, error } = await supabase\r\n                .from('live_sessions')\r\n                .select('*')\r\n                .eq('session_date', today)\r\n                .eq('is_locked', true);\r\n\r\n            if (error) {\r\n                console.error('Failed to fetch live sessions:', error.message);\r\n                // Fall back to cache\r\n                return Array.from(sessionsCache.values()).filter(\r\n                    s => s.session_date === today && s.is_locked\r\n                );\r\n            }\r\n\r\n            // Update cache with fetched data\r\n            sessionsCache.clear();\r\n            (data || []).forEach(session => {\r\n                sessionsCache.set(session.id, session);\r\n            });\r\n            lastFetchTime = now;\r\n\r\n            console.log('ðŸ“‹ Fetched active sessions from Supabase:', (data || []).length, data?.map(s => s.machine_name));\r\n            return data || [];\r\n        } catch (e) {\r\n            console.error('Failed to fetch live sessions:', e);\r\n            // Fall back to cache\r\n            return Array.from(sessionsCache.values()).filter(\r\n                s => s.session_date === today && s.is_locked\r\n            );\r\n        }\r\n    }\r\n\r\n    // Offline - return cached sessions\r\n    if (shouldUseCache) {\r\n        return Array.from(sessionsCache.values()).filter(\r\n            s => s.session_date === today && s.is_locked\r\n        );\r\n    }\r\n\r\n    return [];\r\n};\r\n\r\n// ==========================================\r\n// FETCH SESSION BY MACHINE NAME\r\n// ==========================================\r\nexport const fetchLiveSessionByMachine = async (\r\n    machineName: string,\r\n    shift: string,\r\n    date: string\r\n): Promise<LiveSession | null> => {\r\n    const sessionId = getLiveSessionId(machineName, shift, date);\r\n\r\n    // Check cache first\r\n    if (sessionsCache.has(sessionId)) {\r\n        return sessionsCache.get(sessionId) || null;\r\n    }\r\n\r\n    if (!isSupabaseConfigured) {\r\n        return null;\r\n    }\r\n\r\n    try {\r\n        const { data, error } = await supabase\r\n            .from('live_sessions')\r\n            .select('*')\r\n            .eq('id', sessionId)\r\n            .eq('is_locked', true)\r\n            .maybeSingle();\r\n\r\n        if (error) {\r\n            console.error('Failed to fetch session:', error.message);\r\n            return null;\r\n        }\r\n\r\n        if (data) {\r\n            // Update cache\r\n            sessionsCache.set(sessionId, data);\r\n            console.log('ðŸ“‹ Restored session from Supabase:', machineName);\r\n        }\r\n\r\n        return data;\r\n    } catch (e) {\r\n        console.error('Failed to fetch session by machine:', e);\r\n        return null;\r\n    }\r\n};\r\n\r\n// ==========================================\r\n// GET ACTIVE SUB-MACHINES (Replacement for localStorage check)\r\n// ==========================================\r\nexport const getActiveSubMachinesFromSupabase = async (\r\n    parentMachineName: string,\r\n    subMachineCount: number\r\n): Promise<Set<number>> => {\r\n    const activeSet = new Set<number>();\r\n    const sessions = await fetchActiveSessions();\r\n\r\n    for (let i = 1; i <= subMachineCount; i++) {\r\n        const fullName = `${parentMachineName} - Machine ${i}`;\r\n        const isActive = sessions.some(s => s.machine_name === fullName && s.is_locked);\r\n        if (isActive) {\r\n            activeSet.add(i);\r\n        }\r\n    }\r\n\r\n    return activeSet;\r\n};\r\n\r\n// ==========================================\r\n// SUBSCRIBE TO SESSION CHANGES (Real-time)\r\n// ==========================================\r\nexport const subscribeToSessionChanges = (\r\n    onUpdate: (sessions: LiveSession[]) => void\r\n) => {\r\n    if (!isSupabaseConfigured) {\r\n        return () => { }; // No-op unsubscribe\r\n    }\r\n\r\n    const today = new Date().toISOString().split('T')[0];\r\n\r\n    const channel = supabase\r\n        .channel('live-sessions-changes')\r\n        .on(\r\n            'postgres_changes',\r\n            { event: '*', schema: 'public', table: 'live_sessions' },\r\n            async (payload) => {\r\n                console.log('ðŸ”„ Real-time session update received:', payload.eventType);\r\n                // Refetch all sessions on any change\r\n                const sessions = await fetchActiveSessions();\r\n                onUpdate(sessions);\r\n            }\r\n        )\r\n        .subscribe((status) => {\r\n            console.log('ðŸ“¡ Session subscription status:', status);\r\n        });\r\n\r\n    return () => {\r\n        supabase.removeChannel(channel);\r\n    };\r\n};\r\n\r\n// ==========================================\r\n// SYNC PENDING SESSIONS (On reconnection)\r\n// ==========================================\r\nexport const syncPendingSessions = async (): Promise<void> => {\r\n    if (!isSupabaseConfigured) return;\r\n\r\n    // Any sessions in cache that might not be synced yet\r\n    for (const session of Array.from(sessionsCache.values())) {\r\n        try {\r\n            await supabase\r\n                .from('live_sessions')\r\n                .upsert({\r\n                    id: session.id,\r\n                    machine_name: session.machine_name,\r\n                    operator_name: session.operator_name,\r\n                    order_number: session.order_number,\r\n                    product: session.product,\r\n                    batch_number: session.batch_number,\r\n                    shift: session.shift,\r\n                    session_date: session.session_date,\r\n                    is_locked: session.is_locked,\r\n                    updated_at: new Date().toISOString(),\r\n                }, { onConflict: 'id' });\r\n        } catch (e) {\r\n            console.error('Failed to sync session:', session.id, e);\r\n        }\r\n    }\r\n};\r\n\r\n// ==========================================\r\n// ACTIVITY FEED - Real-time machine events\r\n// ==========================================\r\n\r\nexport type ActivityEventType =\r\n    | 'machine_start'\r\n    | 'machine_pause'\r\n    | 'machine_resume'\r\n    | 'waste_recorded'\r\n    | 'downtime_recorded'\r\n    | 'pallet_scanned'\r\n    | 'cases_added'\r\n    | 'sachet_mass_added'\r\n    | 'shift_submitted'\r\n    | 'speed_recorded';\r\n\r\nexport interface ActivityEvent {\r\n    id: string;\r\n    type: ActivityEventType;\r\n    machine_name: string;\r\n    operator_name?: string;\r\n    message: string;\r\n    details?: string;\r\n    timestamp: Date;\r\n}\r\n\r\n// In-memory activity log (most recent first)\r\nlet activityLog: ActivityEvent[] = [];\r\nconst MAX_ACTIVITY_ITEMS = 50;\r\nlet activityListeners: ((events: ActivityEvent[]) => void)[] = [];\r\n\r\n// Add an activity event\r\nexport const addActivityEvent = (event: Omit<ActivityEvent, 'id' | 'timestamp'>) => {\r\n    const newEvent: ActivityEvent = {\r\n        ...event,\r\n        id: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\r\n        timestamp: new Date(),\r\n    };\r\n\r\n    activityLog = [newEvent, ...activityLog].slice(0, MAX_ACTIVITY_ITEMS);\r\n\r\n    // Notify listeners\r\n    activityListeners.forEach(listener => listener([...activityLog]));\r\n\r\n    // Also broadcast to Supabase for cross-device sync\r\n    if (isSupabaseConfigured) {\r\n        broadcastActivityEvent(newEvent);\r\n    }\r\n};\r\n\r\n// Broadcast activity to other clients via Supabase Realtime\r\nconst broadcastActivityEvent = async (event: ActivityEvent) => {\r\n    try {\r\n        const channel = supabase.channel('activity-broadcast');\r\n        await channel.send({\r\n            type: 'broadcast',\r\n            event: 'activity',\r\n            payload: {\r\n                ...event,\r\n                timestamp: event.timestamp.toISOString(),\r\n            },\r\n        });\r\n    } catch (e) {\r\n        // Silently fail - activity feed is non-critical\r\n    }\r\n};\r\n\r\n// Subscribe to activity events\r\nexport const subscribeToActivityFeed = (\r\n    onUpdate: (events: ActivityEvent[]) => void\r\n) => {\r\n    // Add listener\r\n    activityListeners.push(onUpdate);\r\n\r\n    // Send current log immediately\r\n    onUpdate([...activityLog]);\r\n\r\n    // Subscribe to Supabase broadcast for cross-device events\r\n    let channel: ReturnType<typeof supabase.channel> | null = null;\r\n\r\n    if (isSupabaseConfigured) {\r\n        channel = supabase\r\n            .channel('activity-broadcast')\r\n            .on('broadcast', { event: 'activity' }, (payload) => {\r\n                const eventData = payload.payload as ActivityEvent & { timestamp: string };\r\n                const event: ActivityEvent = {\r\n                    ...eventData,\r\n                    timestamp: new Date(eventData.timestamp),\r\n                };\r\n\r\n                // Avoid duplicates\r\n                if (!activityLog.some(e => e.id === event.id)) {\r\n                    activityLog = [event, ...activityLog].slice(0, MAX_ACTIVITY_ITEMS);\r\n                    activityListeners.forEach(listener => listener([...activityLog]));\r\n                }\r\n            })\r\n            .subscribe();\r\n    }\r\n\r\n    // Return unsubscribe function\r\n    return () => {\r\n        activityListeners = activityListeners.filter(l => l !== onUpdate);\r\n        if (channel) {\r\n            supabase.removeChannel(channel);\r\n        }\r\n    };\r\n};\r\n\r\n// Get current activity log\r\nexport const getActivityLog = (): ActivityEvent[] => [...activityLog];\r\n\r\n// Clear activity log\r\nexport const clearActivityLog = () => {\r\n    activityLog = [];\r\n    activityListeners.forEach(listener => listener([]));\r\n};\r\n\r\n// ==========================================\r\n// ENTRY SYNC - Real-time cross-device sync\r\n// ==========================================\r\n\r\n// Sync all entries to Supabase for cross-device access\r\n// Note: Requires entries_json column in live_sessions table\r\nexport const syncEntriesToSupabase = async (\r\n    machineName: string,\r\n    shift: string,\r\n    date: string,\r\n    entries: SyncedEntries\r\n): Promise<boolean> => {\r\n    if (!isSupabaseConfigured) return false;\r\n\r\n    const sessionId = getLiveSessionId(machineName, shift, date);\r\n    const entriesJson = JSON.stringify(entries);\r\n\r\n    try {\r\n        const { error } = await supabase\r\n            .from('live_sessions')\r\n            .update({\r\n                entries_json: entriesJson,\r\n                updated_at: new Date().toISOString(),\r\n            })\r\n            .eq('id', sessionId);\r\n\r\n        if (error) {\r\n            // Silently fail if entries_json column doesn't exist yet\r\n            if (error.message.includes('entries_json') || error.message.includes('column')) {\r\n                // Column doesn't exist - sync feature not available yet\r\n                return false;\r\n            }\r\n            console.error('Failed to sync entries:', error.message);\r\n            return false;\r\n        }\r\n\r\n        console.log('ðŸ“¦ Entries synced to Supabase:', sessionId);\r\n        return true;\r\n    } catch (e) {\r\n        // Silently fail - sync feature may not be available\r\n        return false;\r\n    }\r\n};\r\n\r\n// Fetch entries from Supabase for a session\r\n// Note: Requires entries_json column in live_sessions table\r\nexport const fetchEntriesFromSupabase = async (\r\n    machineName: string,\r\n    shift: string,\r\n    date: string\r\n): Promise<SyncedEntries | null> => {\r\n    if (!isSupabaseConfigured) return null;\r\n\r\n    const sessionId = getLiveSessionId(machineName, shift, date);\r\n\r\n    try {\r\n        const { data, error } = await supabase\r\n            .from('live_sessions')\r\n            .select('entries_json')\r\n            .eq('id', sessionId)\r\n            .maybeSingle();\r\n\r\n        if (error) {\r\n            // Silently fail if entries_json column doesn't exist yet\r\n            if (error.message.includes('entries_json') || error.message.includes('column')) {\r\n                return null;\r\n            }\r\n            console.error('Failed to fetch entries:', error.message);\r\n            return null;\r\n        }\r\n\r\n        if (data?.entries_json) {\r\n            const entries = JSON.parse(data.entries_json) as SyncedEntries;\r\n            console.log('ðŸ“¦ Entries restored from Supabase:', sessionId);\r\n            return entries;\r\n        }\r\n\r\n        return null;\r\n    } catch (e) {\r\n        // Silently fail - sync feature may not be available\r\n        return null;\r\n    }\r\n};\r\n\r\n// Subscribe to entry changes for real-time sync\r\nexport const subscribeToEntryChanges = (\r\n    machineName: string,\r\n    shift: string,\r\n    date: string,\r\n    onEntriesUpdate: (entries: SyncedEntries) => void\r\n) => {\r\n    if (!isSupabaseConfigured) {\r\n        return () => { }; // No-op unsubscribe\r\n    }\r\n\r\n    const sessionId = getLiveSessionId(machineName, shift, date);\r\n\r\n    const channel = supabase\r\n        .channel(`entries-${sessionId}`)\r\n        .on(\r\n            'postgres_changes',\r\n            {\r\n                event: 'UPDATE',\r\n                schema: 'public',\r\n                table: 'live_sessions',\r\n                filter: `id=eq.${sessionId}`\r\n            },\r\n            (payload) => {\r\n                const newData = payload.new as { entries_json?: string };\r\n                if (newData.entries_json) {\r\n                    try {\r\n                        const entries = JSON.parse(newData.entries_json) as SyncedEntries;\r\n                        console.log('ðŸ”„ Real-time entries update received:', sessionId);\r\n                        onEntriesUpdate(entries);\r\n                    } catch (e) {\r\n                        console.error('Failed to parse entries update:', e);\r\n                    }\r\n                }\r\n            }\r\n        )\r\n        .subscribe((status) => {\r\n            console.log('ðŸ“¡ Entry sync subscription status:', status, sessionId);\r\n        });\r\n\r\n    return () => {\r\n        supabase.removeChannel(channel);\r\n    };\r\n};\r\n\r\n// Helper to safely convert timestamp to ISO string\r\nconst toISOString = (timestamp: Date | string): string => {\r\n    if (typeof timestamp === 'string') return timestamp;\r\n    if (timestamp instanceof Date) return timestamp.toISOString();\r\n    return new Date(timestamp).toISOString();\r\n};\r\n\r\n// Helper to convert local entries to synced format\r\nexport const convertToSyncedEntries = (\r\n    wasteEntries: { id: string; waste: number; wasteType: string; timestamp: Date | string }[],\r\n    downtimeEntries: { id: string; downtime: number; downtimeReason: string; timestamp: Date | string }[],\r\n    speedEntries: { id: string; speed: number; timestamp: Date | string }[],\r\n    sachetMassEntries: { id: string; mass: number; timestamp: Date | string }[],\r\n    looseCasesEntries: { id: string; batchNumber: string; cases: number; timestamp: Date | string }[],\r\n    palletScanEntries: { id: string; qrCode: string; batchNumber: string; palletNumber: string; casesCount: number; timestamp: Date | string; ignored?: boolean }[]\r\n): SyncedEntries => {\r\n    return {\r\n        wasteEntries: wasteEntries.map(e => ({\r\n            id: e.id,\r\n            waste: e.waste,\r\n            wasteType: e.wasteType,\r\n            timestamp: toISOString(e.timestamp),\r\n        })),\r\n        downtimeEntries: downtimeEntries.map(e => ({\r\n            id: e.id,\r\n            downtime: e.downtime,\r\n            downtimeReason: e.downtimeReason,\r\n            timestamp: toISOString(e.timestamp),\r\n        })),\r\n        speedEntries: speedEntries.map(e => ({\r\n            id: e.id,\r\n            speed: e.speed,\r\n            timestamp: toISOString(e.timestamp),\r\n        })),\r\n        sachetMassEntries: sachetMassEntries.map(e => ({\r\n            id: e.id,\r\n            mass: e.mass,\r\n            timestamp: toISOString(e.timestamp),\r\n        })),\r\n        looseCasesEntries: looseCasesEntries.map(e => ({\r\n            id: e.id,\r\n            batchNumber: e.batchNumber,\r\n            cases: e.cases,\r\n            timestamp: toISOString(e.timestamp),\r\n        })),\r\n        palletScanEntries: palletScanEntries.map(e => ({\r\n            id: e.id,\r\n            qrCode: e.qrCode,\r\n            batchNumber: e.batchNumber,\r\n            palletNumber: e.palletNumber,\r\n            casesCount: e.casesCount,\r\n            timestamp: toISOString(e.timestamp),\r\n            ignored: e.ignored,\r\n        })),\r\n    };\r\n};\r\n\r\n// Helper to convert synced entries back to local format\r\nexport const convertFromSyncedEntries = (synced: SyncedEntries) => {\r\n    return {\r\n        wasteEntries: synced.wasteEntries.map(e => ({\r\n            id: e.id,\r\n            waste: e.waste,\r\n            wasteType: e.wasteType,\r\n            timestamp: new Date(e.timestamp),\r\n        })),\r\n        downtimeEntries: synced.downtimeEntries.map(e => ({\r\n            id: e.id,\r\n            downtime: e.downtime,\r\n            downtimeReason: e.downtimeReason,\r\n            timestamp: new Date(e.timestamp),\r\n        })),\r\n        speedEntries: synced.speedEntries.map(e => ({\r\n            id: e.id,\r\n            speed: e.speed,\r\n            timestamp: new Date(e.timestamp),\r\n        })),\r\n        sachetMassEntries: synced.sachetMassEntries.map(e => ({\r\n            id: e.id,\r\n            mass: e.mass,\r\n            timestamp: new Date(e.timestamp),\r\n        })),\r\n        looseCasesEntries: synced.looseCasesEntries.map(e => ({\r\n            id: e.id,\r\n            batchNumber: e.batchNumber,\r\n            cases: e.cases,\r\n            timestamp: new Date(e.timestamp),\r\n        })),\r\n        palletScanEntries: synced.palletScanEntries.map(e => ({\r\n            id: e.id,\r\n            qrCode: e.qrCode,\r\n            batchNumber: e.batchNumber,\r\n            palletNumber: e.palletNumber,\r\n            casesCount: e.casesCount,\r\n            timestamp: new Date(e.timestamp),\r\n            ignored: e.ignored,\r\n        })),\r\n    };\r\n};\r\n","export interface WasteEntry {\r\n  id: string;\r\n  waste: number;\r\n  wasteType: string;\r\n  timestamp: Date;\r\n}\r\n\r\nexport interface DowntimeEntry {\r\n  id: string;\r\n  downtime: number;\r\n  downtimeReason: string;\r\n  notes?: string;\r\n  timestamp: Date;\r\n}\r\n\r\n// Production timer state for tracking run time and pauses\r\nexport interface ProductionState {\r\n  isRunning: boolean;\r\n  startTime: Date | null;       // When production started\r\n  pausedAt: Date | null;        // When current pause began\r\n  totalRunTimeMs: number;       // Accumulated run time in milliseconds\r\n  lastResumedAt: Date | null;   // When last resumed from pause\r\n}\r\n\r\nexport interface SpeedEntry {\r\n  id: string;\r\n  speed: number;\r\n  timestamp: Date;\r\n}\r\n\r\nexport interface SachetMassEntry {\r\n  id: string;\r\n  mass: number; // in grams\r\n  timestamp: Date;\r\n  ignored?: boolean; // Can be set to ignore but not deleted\r\n}\r\n\r\n// Loose cases entry - for cases not part of a full pallet\r\nexport interface LooseCasesEntry {\r\n  id: string;\r\n  batchNumber: string; // 5-digit batch number\r\n  cases: number; // number of loose cases\r\n  timestamp: Date;\r\n  ignored?: boolean;\r\n}\r\n\r\n// Pallet Scan entry - QR code is 13 digits: BBBBBPPPPCCCC\r\n// B = batch number (5 digits), P = pallet number (4 digits), C = cases count (4 digits)\r\nexport interface PalletScanEntry {\r\n  id: string;\r\n  qrCode: string; // Full 13-digit QR code\r\n  batchNumber: string; // Extracted: first 5 digits\r\n  palletNumber: string; // Extracted: digits 6-9 (4 digits)\r\n  casesCount: number; // Extracted: last 4 digits\r\n  timestamp: Date;\r\n  ignored?: boolean;\r\n}\r\n\r\n// Legacy CasesPerHourEntry - kept for backwards compatibility\r\nexport interface CasesPerHourEntry {\r\n  id: string;\r\n  cases: number;\r\n  hour: number;\r\n  timestamp: Date;\r\n  ignored?: boolean;\r\n}\r\n\r\nexport interface ShiftData {\r\n  id: string;\r\n  operatorName: string;\r\n  machine: string;\r\n  subMachine?: string; // For machines that are groups (e.g., \"Universal 2 - Machine 1\")\r\n  orderNumber: string;\r\n  product: string;\r\n  batchNumber: string;\r\n  shift: string;\r\n  date: string;\r\n  wasteEntries: WasteEntry[];\r\n  downtimeEntries: DowntimeEntry[];\r\n  speedEntries?: SpeedEntry[];\r\n  sachetMassEntries?: SachetMassEntry[];\r\n  casesPerHourEntries?: CasesPerHourEntry[]; // Legacy - kept for backwards compatibility\r\n  looseCasesEntries?: LooseCasesEntry[]; // New: loose cases with batch number\r\n  palletScanEntries?: PalletScanEntry[];\r\n  submittedAt: Date;\r\n  totalWaste: number;\r\n  totalDowntime: number;\r\n}\r\n\r\nexport interface ShiftSession {\r\n  machineName: string;\r\n  operatorName: string;\r\n  orderNumber: string;\r\n  product: string;\r\n  batchNumber: string;\r\n  shift: string;\r\n  date: string;\r\n  locked: boolean; // Once set, these values are locked for the shift\r\n  // Entry data persisted with session\r\n  wasteEntries?: WasteEntry[];\r\n  downtimeEntries?: DowntimeEntry[];\r\n  speedEntries?: SpeedEntry[];\r\n  sachetMassEntries?: SachetMassEntry[];\r\n  casesPerHourEntries?: CasesPerHourEntry[]; // Legacy\r\n  looseCasesEntries?: LooseCasesEntry[]; // New\r\n  palletScanEntries?: PalletScanEntry[];\r\n}\r\n\r\nexport interface Machine {\r\n  id: string;\r\n  name: string;\r\n  status: 'running' | 'idle' | 'maintenance';\r\n  currentOperator?: string;\r\n  currentOrder?: string;\r\n  currentShift?: string;\r\n  lastSubmission?: string;\r\n  todayWaste?: number;\r\n  todayDowntime?: number;\r\n  subMachineCount?: number; // Number of sub-machines (e.g., 4 for \"Universal 2\")\r\n}\r\n\r\n// ==============================================\r\n// DEFAULT DATA\r\n// ==============================================\r\n\r\nexport const OPERATORS: string[] = [];\r\nexport const MACHINES: Machine[] = [];\r\n\r\n// Waste Types - common manufacturing waste categories\r\nexport const WASTE_TYPES: string[] = [\r\n  'Start-up Waste',\r\n  'Changeover Waste',\r\n  'Defective Product',\r\n  'Material Spillage',\r\n];\r\n\r\n// Downtime Reasons - categorized by planned vs unplanned\r\nexport const PLANNED_DOWNTIME_REASONS: string[] = [\r\n  'Scheduled Maintenance',\r\n  'Changeover',\r\n];\r\n\r\nexport const UNPLANNED_DOWNTIME_REASONS: string[] = [\r\n  'Machine Breakdown',\r\n  'Material Shortage',\r\n];\r\n\r\n// Combined downtime reasons for selection\r\nexport const DOWNTIME_REASONS: string[] = [\r\n  'Machine Breakdown',\r\n  'Scheduled Maintenance',\r\n  'Changeover',\r\n  'Material Shortage',\r\n];\r\n\r\nexport const ORDER_NUMBERS: string[] = [];\r\nexport const PRODUCTS: string[] = [];\r\nexport const BATCH_NUMBERS: string[] = [];\r\n\r\n","import { ShiftData, Machine, MACHINES } from '../types';\r\nimport {\r\n  fetchMachines,\r\n  upsertMachine,\r\n  removeMachine,\r\n  syncMachinesToSupabase,\r\n  subscribeMachineChanges,\r\n  MachineRecord,\r\n  submitShiftData,\r\n  isSupabaseConfigured\r\n} from './supabase';\r\n\r\nconst STORAGE_KEY = 'waste_downtime_history';\r\nconst MACHINES_KEY = 'machines_data';\r\nconst MACHINES_SYNC_KEY = 'machines_last_sync';\r\nconst FAILED_SUBMISSIONS_KEY = 'failed_submissions_queue';\r\nconst HISTORY_MAX_DAYS = 90; // Keep history for 90 days\r\nconst HISTORY_MAX_ENTRIES = 1000; // Maximum entries to keep\r\n\r\n// ==========================================\r\n// FAILED SUBMISSIONS RETRY QUEUE\r\n// ==========================================\r\n\r\ninterface FailedSubmission {\r\n  id: string;\r\n  timestamp: string;\r\n  retryCount: number;\r\n  maxRetries: number;\r\n  data: {\r\n    shiftData: any;\r\n    wasteEntries: any[];\r\n    downtimeEntries: any[];\r\n    speedEntries?: any[];\r\n    sachetMassEntries?: any[];\r\n    looseCasesEntries?: any[];\r\n    palletScanEntries?: any[];\r\n  };\r\n  error: string;\r\n}\r\n\r\n// Get failed submissions queue\r\nexport const getFailedSubmissions = (): FailedSubmission[] => {\r\n  const stored = localStorage.getItem(FAILED_SUBMISSIONS_KEY);\r\n  if (!stored) return [];\r\n  try {\r\n    return JSON.parse(stored);\r\n  } catch {\r\n    return [];\r\n  }\r\n};\r\n\r\n// Add a failed submission to the retry queue\r\nexport const addFailedSubmission = (\r\n  data: FailedSubmission['data'],\r\n  error: string\r\n): void => {\r\n  const queue = getFailedSubmissions();\r\n  const newEntry: FailedSubmission = {\r\n    id: `failed_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n    timestamp: new Date().toISOString(),\r\n    retryCount: 0,\r\n    maxRetries: 3,\r\n    data,\r\n    error,\r\n  };\r\n  queue.push(newEntry);\r\n  localStorage.setItem(FAILED_SUBMISSIONS_KEY, JSON.stringify(queue));\r\n};\r\n\r\n// Remove a submission from the failed queue\r\nexport const removeFailedSubmission = (id: string): void => {\r\n  const queue = getFailedSubmissions();\r\n  const filtered = queue.filter(s => s.id !== id);\r\n  localStorage.setItem(FAILED_SUBMISSIONS_KEY, JSON.stringify(filtered));\r\n};\r\n\r\n// Retry all failed submissions\r\nexport const retryFailedSubmissions = async (): Promise<{\r\n  succeeded: number;\r\n  failed: number;\r\n  remaining: number;\r\n}> => {\r\n  if (!isSupabaseConfigured) {\r\n    return { succeeded: 0, failed: 0, remaining: getFailedSubmissions().length };\r\n  }\r\n\r\n  const queue = getFailedSubmissions();\r\n  let succeeded = 0;\r\n  let failed = 0;\r\n\r\n  for (const submission of queue) {\r\n    if (submission.retryCount >= submission.maxRetries) {\r\n      // Max retries reached, keep in queue but don't retry\r\n      failed++;\r\n      continue;\r\n    }\r\n\r\n    try {\r\n      await submitShiftData(\r\n        submission.data.shiftData,\r\n        submission.data.wasteEntries,\r\n        submission.data.downtimeEntries,\r\n        submission.data.speedEntries,\r\n        submission.data.sachetMassEntries,\r\n        submission.data.looseCasesEntries,\r\n        submission.data.palletScanEntries\r\n      );\r\n      removeFailedSubmission(submission.id);\r\n      succeeded++;\r\n    } catch (e) {\r\n      // Update retry count\r\n      const updatedQueue = getFailedSubmissions().map(s =>\r\n        s.id === submission.id\r\n          ? { ...s, retryCount: s.retryCount + 1, error: String(e) }\r\n          : s\r\n      );\r\n      localStorage.setItem(FAILED_SUBMISSIONS_KEY, JSON.stringify(updatedQueue));\r\n      failed++;\r\n    }\r\n  }\r\n\r\n  return {\r\n    succeeded,\r\n    failed,\r\n    remaining: getFailedSubmissions().length,\r\n  };\r\n};\r\n\r\n// Clear all failed submissions (manual clear)\r\nexport const clearFailedSubmissions = (): void => {\r\n  localStorage.removeItem(FAILED_SUBMISSIONS_KEY);\r\n};\r\n\r\n// ==========================================\r\n// LOCALSTORAGE CLEANUP\r\n// ==========================================\r\n\r\n// Clean up old history entries\r\nexport const cleanupOldHistory = (): { removed: number; remaining: number } => {\r\n  const history = getShiftHistory();\r\n  const now = new Date();\r\n  const cutoffDate = new Date(now.getTime() - HISTORY_MAX_DAYS * 24 * 60 * 60 * 1000);\r\n\r\n  // Filter out entries older than cutoff date\r\n  let cleaned = history.filter(item => {\r\n    const itemDate = new Date(item.date);\r\n    return itemDate >= cutoffDate;\r\n  });\r\n\r\n  // Also limit to max entries (keep most recent)\r\n  if (cleaned.length > HISTORY_MAX_ENTRIES) {\r\n    cleaned = cleaned.slice(0, HISTORY_MAX_ENTRIES);\r\n  }\r\n\r\n  const removed = history.length - cleaned.length;\r\n\r\n  if (removed > 0) {\r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(cleaned));\r\n    console.log(`Cleaned up ${removed} old history entries`);\r\n  }\r\n\r\n  return { removed, remaining: cleaned.length };\r\n};\r\n\r\n// Get localStorage usage stats\r\nexport const getStorageStats = (): {\r\n  historyCount: number;\r\n  failedCount: number;\r\n  totalSizeKB: number;\r\n  oldestEntry: string | null;\r\n} => {\r\n  const history = getShiftHistory();\r\n  const failed = getFailedSubmissions();\r\n\r\n  // Estimate total localStorage size\r\n  let totalSize = 0;\r\n  for (let i = 0; i < localStorage.length; i++) {\r\n    const key = localStorage.key(i);\r\n    if (key) {\r\n      const value = localStorage.getItem(key) || '';\r\n      totalSize += key.length + value.length;\r\n    }\r\n  }\r\n\r\n  const oldestEntry = history.length > 0\r\n    ? history[history.length - 1].date\r\n    : null;\r\n\r\n  return {\r\n    historyCount: history.length,\r\n    failedCount: failed.length,\r\n    totalSizeKB: Math.round(totalSize / 1024),\r\n    oldestEntry,\r\n  };\r\n};\r\n\r\n// Run cleanup on app startup (debounced to run once per day)\r\nexport const maybeRunCleanup = (): void => {\r\n  const lastCleanupKey = 'last_storage_cleanup';\r\n  const lastCleanup = localStorage.getItem(lastCleanupKey);\r\n  const now = new Date();\r\n\r\n  if (lastCleanup) {\r\n    const lastDate = new Date(lastCleanup);\r\n    const hoursSinceCleanup = (now.getTime() - lastDate.getTime()) / (1000 * 60 * 60);\r\n    if (hoursSinceCleanup < 24) {\r\n      return; // Already cleaned up today\r\n    }\r\n  }\r\n\r\n  // Run cleanup\r\n  const result = cleanupOldHistory();\r\n  localStorage.setItem(lastCleanupKey, now.toISOString());\r\n\r\n  if (result.removed > 0) {\r\n    console.log(`Storage cleanup: removed ${result.removed} entries, ${result.remaining} remaining`);\r\n  }\r\n};\r\n\r\n// Flag to track if we're using Supabase\r\nlet useSupabase = true;\r\nlet machinesCache: Machine[] | null = null;\r\nlet machinesListeners: ((machines: Machine[]) => void)[] = [];\r\n\r\n// Convert Supabase record to local Machine type\r\nconst toLocalMachine = (record: MachineRecord): Machine => ({\r\n  id: record.id,\r\n  name: record.name,\r\n  status: record.status,\r\n  currentOperator: record.current_operator,\r\n  currentOrder: record.current_order,\r\n  currentShift: record.current_shift,\r\n  lastSubmission: record.last_submission,\r\n  todayWaste: record.today_waste,\r\n  todayDowntime: record.today_downtime,\r\n  subMachineCount: record.sub_machine_count,\r\n});\r\n\r\n// Convert local Machine to Supabase record\r\nconst toSupabaseRecord = (machine: Machine): MachineRecord => ({\r\n  id: machine.id,\r\n  name: machine.name,\r\n  status: machine.status,\r\n  current_operator: machine.currentOperator,\r\n  current_order: machine.currentOrder,\r\n  current_shift: machine.currentShift,\r\n  last_submission: machine.lastSubmission,\r\n  today_waste: machine.todayWaste,\r\n  today_downtime: machine.todayDowntime,\r\n  sub_machine_count: machine.subMachineCount,\r\n});\r\n\r\n// Initialize machines from Supabase\r\nexport const initializeMachines = async (): Promise<Machine[]> => {\r\n  try {\r\n    const records = await fetchMachines();\r\n\r\n    if (records.length > 0) {\r\n      machinesCache = records.map(toLocalMachine);\r\n      // Also save to localStorage as backup\r\n      localStorage.setItem(MACHINES_KEY, JSON.stringify(machinesCache));\r\n      localStorage.setItem(MACHINES_SYNC_KEY, new Date().toISOString());\r\n      return machinesCache;\r\n    } else {\r\n      // No machines in Supabase, sync default machines\r\n      console.log('No machines in Supabase, syncing defaults...');\r\n      const defaultMachines = MACHINES.map(toSupabaseRecord);\r\n      await syncMachinesToSupabase(defaultMachines);\r\n      machinesCache = MACHINES;\r\n      localStorage.setItem(MACHINES_KEY, JSON.stringify(MACHINES));\r\n      return MACHINES;\r\n    }\r\n  } catch (error) {\r\n    console.error('Failed to initialize from Supabase, using localStorage:', error);\r\n    useSupabase = false;\r\n    return getMachinesDataLocal();\r\n  }\r\n};\r\n\r\n// Subscribe to real-time machine updates - OPTIMIZED\r\nexport const subscribeToMachineUpdates = (callback: (machines: Machine[]) => void) => {\r\n  machinesListeners.push(callback);\r\n\r\n  // Provide current machines getter for optimized real-time updates\r\n  const getCurrentMachines = (): MachineRecord[] => {\r\n    const current = machinesCache || getMachinesDataLocal();\r\n    return current.map(toSupabaseRecord);\r\n  };\r\n\r\n  // Set up Supabase real-time subscription with optimized handler\r\n  const unsubscribe = subscribeMachineChanges(\r\n    (records) => {\r\n      machinesCache = records.map(toLocalMachine);\r\n      localStorage.setItem(MACHINES_KEY, JSON.stringify(machinesCache));\r\n\r\n      // Notify all listeners\r\n      machinesListeners.forEach(listener => listener(machinesCache!));\r\n    },\r\n    getCurrentMachines\r\n  );\r\n\r\n  // Return cleanup function\r\n  return () => {\r\n    machinesListeners = machinesListeners.filter(l => l !== callback);\r\n    if (machinesListeners.length === 0) {\r\n      unsubscribe();\r\n    }\r\n  };\r\n};\r\n\r\n// Get machines from localStorage (fallback)\r\nconst getMachinesDataLocal = (): Machine[] => {\r\n  const stored = localStorage.getItem(MACHINES_KEY);\r\n  if (!stored) {\r\n    localStorage.setItem(MACHINES_KEY, JSON.stringify(MACHINES));\r\n    return MACHINES;\r\n  }\r\n\r\n  try {\r\n    return JSON.parse(stored);\r\n  } catch {\r\n    return MACHINES;\r\n  }\r\n};\r\n\r\n// Save shift data to local storage\r\nexport const saveShiftData = (data: ShiftData): void => {\r\n  const existing = getShiftHistory();\r\n  existing.unshift(data);\r\n  localStorage.setItem(STORAGE_KEY, JSON.stringify(existing));\r\n\r\n  // Update machine data\r\n  updateMachineLastSubmission(data.machine, data.submittedAt.toISOString());\r\n};\r\n\r\n// Get all shift history\r\nexport const getShiftHistory = (): ShiftData[] => {\r\n  const stored = localStorage.getItem(STORAGE_KEY);\r\n  if (!stored) return [];\r\n\r\n  try {\r\n    const parsed = JSON.parse(stored);\r\n    return parsed.map((item: any) => ({\r\n      ...item,\r\n      submittedAt: new Date(item.submittedAt),\r\n      wasteEntries: item.wasteEntries.map((w: any) => ({\r\n        ...w,\r\n        timestamp: new Date(w.timestamp),\r\n      })),\r\n      downtimeEntries: item.downtimeEntries.map((d: any) => ({\r\n        ...d,\r\n        timestamp: new Date(d.timestamp),\r\n      })),\r\n    }));\r\n  } catch {\r\n    return [];\r\n  }\r\n};\r\n\r\n// Get shift history for a specific date range\r\nexport const getShiftHistoryByDateRange = (startDate: Date, endDate: Date): ShiftData[] => {\r\n  const history = getShiftHistory();\r\n  return history.filter(item => {\r\n    const itemDate = new Date(item.date);\r\n    return itemDate >= startDate && itemDate <= endDate;\r\n  });\r\n};\r\n\r\n// Get shift history for a specific machine\r\nexport const getShiftHistoryByMachine = (machineName: string): ShiftData[] => {\r\n  const history = getShiftHistory();\r\n  return history.filter(item => item.machine === machineName);\r\n};\r\n\r\n// Get today's statistics\r\nexport const getTodayStats = () => {\r\n  const today = new Date().toISOString().split('T')[0];\r\n  const history = getShiftHistory();\r\n  const todayData = history.filter(item => item.date === today);\r\n\r\n  const totalWaste = todayData.reduce((sum, item) => sum + item.totalWaste, 0);\r\n  const totalDowntime = todayData.reduce((sum, item) => sum + item.totalDowntime, 0);\r\n  const submissionCount = todayData.length;\r\n\r\n  return { totalWaste, totalDowntime, submissionCount };\r\n};\r\n\r\n// Update machine last submission\r\nexport const updateMachineLastSubmission = (machineName: string, timestamp: string): void => {\r\n  const machines = getMachinesData();\r\n  const machineIndex = machines.findIndex(m => m.name === machineName);\r\n  if (machineIndex !== -1) {\r\n    machines[machineIndex].lastSubmission = getTimeAgo(new Date(timestamp));\r\n  }\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(machines));\r\n};\r\n\r\n// Get machines data with local modifications\r\nexport const getMachinesData = (): Machine[] => {\r\n  // Return cache if available\r\n  if (machinesCache) {\r\n    return machinesCache;\r\n  }\r\n\r\n  // Otherwise return from localStorage\r\n  return getMachinesDataLocal();\r\n};\r\n\r\n// Update a single machine\r\nexport const updateMachine = async (machineId: string, updates: Partial<Machine>): Promise<void> => {\r\n  const machines = getMachinesData();\r\n  const index = machines.findIndex(m => m.id === machineId);\r\n  if (index !== -1) {\r\n    machines[index] = { ...machines[index], ...updates };\r\n    machinesCache = machines;\r\n    localStorage.setItem(MACHINES_KEY, JSON.stringify(machines));\r\n\r\n    // Sync to Supabase\r\n    if (useSupabase) {\r\n      try {\r\n        await upsertMachine(toSupabaseRecord(machines[index]));\r\n      } catch (error) {\r\n        console.error('Failed to sync machine update to Supabase:', error);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n// Add a new machine\r\nexport const addMachine = async (machine: Machine): Promise<void> => {\r\n  const machines = getMachinesData();\r\n  machines.push(machine);\r\n  machinesCache = machines;\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(machines));\r\n\r\n  // Sync to Supabase\r\n  if (useSupabase) {\r\n    try {\r\n      await upsertMachine(toSupabaseRecord(machine));\r\n    } catch (error) {\r\n      console.error('Failed to sync new machine to Supabase:', error);\r\n    }\r\n  }\r\n};\r\n\r\n// Delete a machine\r\nexport const deleteMachine = async (machineId: string): Promise<void> => {\r\n  const machines = getMachinesData();\r\n  const filtered = machines.filter(m => m.id !== machineId);\r\n  machinesCache = filtered;\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(filtered));\r\n\r\n  // Sync to Supabase\r\n  if (useSupabase) {\r\n    try {\r\n      await removeMachine(machineId);\r\n    } catch (error) {\r\n      console.error('Failed to delete machine from Supabase:', error);\r\n    }\r\n  }\r\n};\r\n\r\n// Reset machines to default\r\nexport const resetMachines = async (): Promise<void> => {\r\n  machinesCache = MACHINES;\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(MACHINES));\r\n\r\n  // Sync to Supabase\r\n  if (useSupabase) {\r\n    try {\r\n      await syncMachinesToSupabase(MACHINES.map(toSupabaseRecord));\r\n    } catch (error) {\r\n      console.error('Failed to reset machines in Supabase:', error);\r\n    }\r\n  }\r\n};\r\n\r\n// Helper function to format time ago\r\nexport const getTimeAgo = (date: Date): string => {\r\n  const now = new Date();\r\n  const diffMs = now.getTime() - date.getTime();\r\n  const diffMins = Math.floor(diffMs / 60000);\r\n  const diffHours = Math.floor(diffMins / 60);\r\n  const diffDays = Math.floor(diffHours / 24);\r\n\r\n  if (diffMins < 1) return 'Just now';\r\n  if (diffMins < 60) return `${diffMins} min ago`;\r\n  if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;\r\n  return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;\r\n};\r\n\r\n// Export data to CSV\r\nexport const exportToCSV = (data: ShiftData[], filename: string): void => {\r\n  const headers = [\r\n    'Date',\r\n    'Shift',\r\n    'Operator',\r\n    'Machine',\r\n    'Order Number',\r\n    'Product',\r\n    'Batch Number',\r\n    'Entry Type',\r\n    'Waste Type',\r\n    'Waste (kg)',\r\n    'Downtime Reason',\r\n    'Downtime (min)',\r\n    'Submitted At',\r\n  ];\r\n\r\n  const rows: string[][] = [];\r\n\r\n  data.forEach(item => {\r\n    const baseRow = [\r\n      item.date,\r\n      item.shift,\r\n      item.operatorName,\r\n      item.machine,\r\n      item.orderNumber,\r\n      item.product,\r\n      item.batchNumber,\r\n    ];\r\n    const submittedAt = new Date(item.submittedAt).toLocaleString();\r\n\r\n    // Add a row for each waste entry\r\n    if (item.wasteEntries && item.wasteEntries.length > 0) {\r\n      item.wasteEntries.forEach(w => {\r\n        rows.push([\r\n          ...baseRow,\r\n          'Waste',\r\n          w.wasteType,\r\n          w.waste.toFixed(2),\r\n          '',\r\n          '',\r\n          submittedAt,\r\n        ]);\r\n      });\r\n    }\r\n\r\n    // Add a row for each downtime entry\r\n    if (item.downtimeEntries && item.downtimeEntries.length > 0) {\r\n      item.downtimeEntries.forEach(d => {\r\n        rows.push([\r\n          ...baseRow,\r\n          'Downtime',\r\n          '',\r\n          '',\r\n          d.downtimeReason,\r\n          d.downtime.toString(),\r\n          submittedAt,\r\n        ]);\r\n      });\r\n    }\r\n\r\n    // If no entries at all, still add one summary row\r\n    if ((!item.wasteEntries || item.wasteEntries.length === 0) &&\r\n      (!item.downtimeEntries || item.downtimeEntries.length === 0)) {\r\n      rows.push([\r\n        ...baseRow,\r\n        'Summary',\r\n        '',\r\n        item.totalWaste.toFixed(2),\r\n        '',\r\n        item.totalDowntime.toString(),\r\n        submittedAt,\r\n      ]);\r\n    }\r\n  });\r\n\r\n  const csvContent = [\r\n    headers.join(','),\r\n    ...rows.map(row => row.map(cell => `\"${cell}\"`).join(',')),\r\n  ].join('\\n');\r\n\r\n  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\r\n  const link = document.createElement('a');\r\n  const url = URL.createObjectURL(blob);\r\n  link.setAttribute('href', url);\r\n  link.setAttribute('download', `${filename}.csv`);\r\n  link.style.visibility = 'hidden';\r\n  document.body.appendChild(link);\r\n  link.click();\r\n  document.body.removeChild(link);\r\n  // Clean up the object URL to prevent memory leak\r\n  URL.revokeObjectURL(url);\r\n};\r\n\r\n// Clear all history (for testing)\r\nexport const clearHistory = (): void => {\r\n  localStorage.removeItem(STORAGE_KEY);\r\n  localStorage.removeItem(MACHINES_KEY);\r\n};\r\n\r\n// ==========================================\r\n// SHARED LINE SPEED - Syncs across sub-machines\r\n// ==========================================\r\n\r\nconst LINE_SPEED_KEY_PREFIX = 'line_speed_';\r\n\r\n/**\r\n * Extract parent machine name from a sub-machine name\r\n * e.g., \"Cubes - Machine 1\" â†’ \"Cubes\"\r\n * e.g., \"Universal 2 - Machine 3\" â†’ \"Universal 2\"\r\n */\r\nexport const getParentMachineName = (machineName: string): string => {\r\n  // Check if it matches the pattern \"Parent - Machine N\"\r\n  const match = machineName.match(/^(.+?)\\s*-\\s*Machine\\s*\\d+$/i);\r\n  if (match) {\r\n    return match[1].trim();\r\n  }\r\n  // Return the original name if no sub-machine pattern found\r\n  return machineName;\r\n};\r\n\r\n/**\r\n * Get the storage key for shared line speed\r\n */\r\nconst getLineSpeedKey = (parentMachineName: string, shift: string, date: string): string => {\r\n  return `${LINE_SPEED_KEY_PREFIX}${parentMachineName}_${shift}_${date}`;\r\n};\r\n\r\n/**\r\n * Save shared line speed (called when any sub-machine sets speed)\r\n */\r\nexport const saveLineSpeed = (\r\n  machineName: string,\r\n  shift: string,\r\n  date: string,\r\n  speed: number\r\n): void => {\r\n  const parentName = getParentMachineName(machineName);\r\n  const key = getLineSpeedKey(parentName, shift, date);\r\n\r\n  const data = {\r\n    speed,\r\n    updatedAt: new Date().toISOString(),\r\n    updatedBy: machineName,\r\n  };\r\n\r\n  localStorage.setItem(key, JSON.stringify(data));\r\n  console.log(`ðŸ’¾ Saved line speed ${speed} PPM for ${parentName}`);\r\n};\r\n\r\n/**\r\n * Get shared line speed (returns the speed set by any sibling machine)\r\n */\r\nexport const getLineSpeed = (\r\n  machineName: string,\r\n  shift: string,\r\n  date: string\r\n): { speed: number; updatedBy: string; updatedAt: string } | null => {\r\n  const parentName = getParentMachineName(machineName);\r\n  const key = getLineSpeedKey(parentName, shift, date);\r\n\r\n  const stored = localStorage.getItem(key);\r\n  if (!stored) return null;\r\n\r\n  try {\r\n    const data = JSON.parse(stored);\r\n    console.log(`ðŸ“– Loaded line speed ${data.speed} PPM for ${parentName} (set by ${data.updatedBy})`);\r\n    return data;\r\n  } catch {\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Clear shared line speed (called when session ends)\r\n */\r\nexport const clearLineSpeed = (\r\n  machineName: string,\r\n  shift: string,\r\n  date: string\r\n): void => {\r\n  const parentName = getParentMachineName(machineName);\r\n  const key = getLineSpeedKey(parentName, shift, date);\r\n  localStorage.removeItem(key);\r\n};\r\n\r\n/**\r\n * Clean up old line speed entries (called periodically)\r\n */\r\nexport const cleanupOldLineSpeeds = (retentionDays: number = 7): number => {\r\n  const cutoff = Date.now() - (retentionDays * 24 * 60 * 60 * 1000);\r\n  let removed = 0;\r\n\r\n  for (let i = localStorage.length - 1; i >= 0; i--) {\r\n    const key = localStorage.key(i);\r\n    if (key?.startsWith(LINE_SPEED_KEY_PREFIX)) {\r\n      try {\r\n        const data = localStorage.getItem(key);\r\n        if (data) {\r\n          const parsed = JSON.parse(data);\r\n          const updatedAt = new Date(parsed.updatedAt).getTime();\r\n          if (updatedAt < cutoff) {\r\n            localStorage.removeItem(key);\r\n            removed++;\r\n          }\r\n        }\r\n      } catch {\r\n        // Invalid data - remove it\r\n        localStorage.removeItem(key);\r\n        removed++;\r\n      }\r\n    }\r\n  }\r\n\r\n  return removed;\r\n};\r\n"],"names":["getLiveSessionId","machineName","shift","date","concat","sessionsCache","Map","lastFetchTime","upsertLiveSession","async","sessionId","session","liveSession","id","machine_name","operator_name","operatorName","order_number","orderNumber","product","batch_number","batchNumber","session_date","is_locked","locked","total_waste","totalWaste","total_downtime","totalDowntime","updated_at","Date","toISOString","set","isSupabaseConfigured","error","supabase","from","upsert","onConflict","console","message","log","e","deleteLiveSession","delete","eq","fetchActiveSessions","now","today","split","shouldUseCache","data","select","Array","values","filter","s","clear","forEach","length","map","fetchLiveSessionByMachine","has","get","maybeSingle","subscribeToSessionChanges","onUpdate","channel","on","event","schema","table","payload","eventType","sessions","subscribe","status","removeChannel","activityLog","activityListeners","subscribeToActivityFeed","push","eventData","_objectSpread","timestamp","some","slice","listener","l","syncEntriesToSupabase","entries","entriesJson","JSON","stringify","update","entries_json","includes","fetchEntriesFromSupabase","parse","subscribeToEntryChanges","onEntriesUpdate","newData","new","convertToSyncedEntries","wasteEntries","downtimeEntries","speedEntries","sachetMassEntries","looseCasesEntries","palletScanEntries","waste","wasteType","downtime","downtimeReason","speed","mass","cases","qrCode","palletNumber","casesCount","ignored","convertFromSyncedEntries","synced","MACHINES","WASTE_TYPES","DOWNTIME_REASONS","STORAGE_KEY","MACHINES_KEY","FAILED_SUBMISSIONS_KEY","getFailedSubmissions","stored","localStorage","getItem","_unused","addFailedSubmission","queue","newEntry","Math","random","toString","substr","retryCount","maxRetries","setItem","removeFailedSubmission","filtered","retryFailedSubmissions","succeeded","failed","remaining","submission","submitShiftData","shiftData","updatedQueue","String","maybeRunCleanup","lastCleanupKey","lastCleanup","lastDate","getTime","result","cleanupOldHistory","history","getShiftHistory","cutoffDate","HISTORY_MAX_DAYS","cleaned","item","removed","useSupabase","machinesCache","machinesListeners","toLocalMachine","record","name","currentOperator","current_operator","currentOrder","current_order","currentShift","current_shift","lastSubmission","last_submission","todayWaste","today_waste","todayDowntime","today_downtime","subMachineCount","sub_machine_count","toSupabaseRecord","machine","initializeMachines","records","fetchMachines","defaultMachines","syncMachinesToSupabase","getMachinesDataLocal","subscribeToMachineUpdates","callback","unsubscribe","subscribeMachineChanges","getCurrentMachines","_unused2","saveShiftData","existing","unshift","updateMachineLastSubmission","submittedAt","w","d","_unused3","getTodayStats","todayData","reduce","sum","submissionCount","machines","getMachinesData","machineIndex","findIndex","m","getTimeAgo","updateMachine","machineId","updates","index","upsertMachine","addMachine","deleteMachine","removeMachine","diffMs","diffMins","floor","diffHours","diffDays","exportToCSV","filename","rows","baseRow","toLocaleString","toFixed","csvContent","join","row","cell","blob","Blob","type","link","document","createElement","url","URL","createObjectURL","setAttribute","style","visibility","body","appendChild","click","removeChild","revokeObjectURL","LINE_SPEED_KEY_PREFIX","getParentMachineName","match","trim","getLineSpeedKey","parentMachineName","saveLineSpeed","parentName","key","updatedAt","updatedBy","getLineSpeed","_unused4"],"ignoreList":[],"sourceRoot":""}