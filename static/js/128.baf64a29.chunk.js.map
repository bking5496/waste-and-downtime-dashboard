{"version":3,"file":"static/js/128.baf64a29.chunk.js","mappings":"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","sources":["lib/liveSession.ts","types.ts","lib/storage.ts"],"sourcesContent":["import { supabase, isSupabaseConfigured } from './supabase';\r\n\r\n// ==========================================\r\n// LIVE SESSIONS - Cross-device sync with offline fallback\r\n// ==========================================\r\n\r\nexport interface LiveSession {\r\n    id: string; // Format: \"machineName_shift_date\"\r\n    machine_name: string;\r\n    operator_name: string;\r\n    order_number: string;\r\n    product: string;\r\n    batch_number: string;\r\n    shift: string;\r\n    session_date: string;\r\n    is_locked: boolean;\r\n    total_waste?: number;\r\n    total_downtime?: number;\r\n    created_at?: string;\r\n    updated_at?: string;\r\n}\r\n\r\n// Generate session ID from components\r\nexport const getLiveSessionId = (machineName: string, shift: string, date: string): string => {\r\n    return `${machineName}_${shift}_${date}`;\r\n};\r\n\r\n// Cache for active sessions (used when offline or for quick lookups)\r\nlet sessionsCache: Map<string, LiveSession> = new Map();\r\nlet lastFetchTime: number = 0;\r\nconst CACHE_TTL_MS = 30000; // 30 seconds cache\r\n\r\n// ==========================================\r\n// UPSERT SESSION (Save/Update)\r\n// ==========================================\r\nexport const upsertLiveSession = async (session: {\r\n    machineName: string;\r\n    operatorName: string;\r\n    orderNumber: string;\r\n    product: string;\r\n    batchNumber: string;\r\n    shift: string;\r\n    date: string;\r\n    locked: boolean;\r\n    totalWaste?: number;\r\n    totalDowntime?: number;\r\n}): Promise<boolean> => {\r\n    const sessionId = getLiveSessionId(session.machineName, session.shift, session.date);\r\n\r\n    const liveSession: LiveSession = {\r\n        id: sessionId,\r\n        machine_name: session.machineName,\r\n        operator_name: session.operatorName,\r\n        order_number: session.orderNumber,\r\n        product: session.product,\r\n        batch_number: session.batchNumber,\r\n        shift: session.shift,\r\n        session_date: session.date,\r\n        is_locked: session.locked,\r\n        total_waste: session.totalWaste || 0,\r\n        total_downtime: session.totalDowntime || 0,\r\n        updated_at: new Date().toISOString(),\r\n    };\r\n\r\n    // Always update local cache first\r\n    sessionsCache.set(sessionId, liveSession);\r\n\r\n    // Try to sync to Supabase\r\n    if (isSupabaseConfigured) {\r\n        try {\r\n            const { error } = await supabase\r\n                .from('live_sessions')\r\n                .upsert({\r\n                    id: sessionId,\r\n                    machine_name: session.machineName,\r\n                    operator_name: session.operatorName,\r\n                    order_number: session.orderNumber,\r\n                    product: session.product,\r\n                    batch_number: session.batchNumber,\r\n                    shift: session.shift,\r\n                    session_date: session.date,\r\n                    is_locked: session.locked,\r\n                    total_waste: session.totalWaste || 0,\r\n                    total_downtime: session.totalDowntime || 0,\r\n                    updated_at: new Date().toISOString(),\r\n                }, { onConflict: 'id' });\r\n\r\n            if (error) {\r\n                console.error('Failed to upsert live session:', error.message);\r\n                return false;\r\n            }\r\n            console.log('âœ… Live session synced to Supabase:', sessionId);\r\n            return true;\r\n        } catch (e) {\r\n            console.error('Failed to upsert live session:', e);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Offline - cached locally, will sync later\r\n    return true;\r\n};\r\n\r\n// ==========================================\r\n// DELETE SESSION (When submitted or cleared)\r\n// ==========================================\r\nexport const deleteLiveSession = async (\r\n    machineName: string,\r\n    shift: string,\r\n    date: string\r\n): Promise<boolean> => {\r\n    const sessionId = getLiveSessionId(machineName, shift, date);\r\n\r\n    // Remove from local cache\r\n    sessionsCache.delete(sessionId);\r\n\r\n    // Try to delete from Supabase\r\n    if (isSupabaseConfigured) {\r\n        try {\r\n            const { error } = await supabase\r\n                .from('live_sessions')\r\n                .delete()\r\n                .eq('id', sessionId);\r\n\r\n            if (error) {\r\n                console.error('Failed to delete live session:', error.message);\r\n                return false;\r\n            }\r\n            return true;\r\n        } catch (e) {\r\n            console.error('Failed to delete live session:', e);\r\n            return false;\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\n// ==========================================\r\n// FETCH ACTIVE SESSIONS (For Dashboard)\r\n// ==========================================\r\nexport const fetchActiveSessions = async (): Promise<LiveSession[]> => {\r\n    const now = Date.now();\r\n    const today = new Date().toISOString().split('T')[0];\r\n\r\n    // Return cache if fresh and online fetch fails\r\n    const shouldUseCache = now - lastFetchTime < CACHE_TTL_MS;\r\n\r\n    if (isSupabaseConfigured) {\r\n        try {\r\n            const { data, error } = await supabase\r\n                .from('live_sessions')\r\n                .select('*')\r\n                .eq('session_date', today)\r\n                .eq('is_locked', true);\r\n\r\n            if (error) {\r\n                console.error('Failed to fetch live sessions:', error.message);\r\n                // Fall back to cache\r\n                return Array.from(sessionsCache.values()).filter(\r\n                    s => s.session_date === today && s.is_locked\r\n                );\r\n            }\r\n\r\n            // Update cache with fetched data\r\n            sessionsCache.clear();\r\n            (data || []).forEach(session => {\r\n                sessionsCache.set(session.id, session);\r\n            });\r\n            lastFetchTime = now;\r\n\r\n            console.log('ðŸ“‹ Fetched active sessions from Supabase:', (data || []).length, data?.map(s => s.machine_name));\r\n            return data || [];\r\n        } catch (e) {\r\n            console.error('Failed to fetch live sessions:', e);\r\n            // Fall back to cache\r\n            return Array.from(sessionsCache.values()).filter(\r\n                s => s.session_date === today && s.is_locked\r\n            );\r\n        }\r\n    }\r\n\r\n    // Offline - return cached sessions\r\n    if (shouldUseCache) {\r\n        return Array.from(sessionsCache.values()).filter(\r\n            s => s.session_date === today && s.is_locked\r\n        );\r\n    }\r\n\r\n    return [];\r\n};\r\n\r\n// ==========================================\r\n// FETCH SESSION BY MACHINE NAME\r\n// ==========================================\r\nexport const fetchLiveSessionByMachine = async (\r\n    machineName: string,\r\n    shift: string,\r\n    date: string\r\n): Promise<LiveSession | null> => {\r\n    const sessionId = getLiveSessionId(machineName, shift, date);\r\n\r\n    // Check cache first\r\n    if (sessionsCache.has(sessionId)) {\r\n        return sessionsCache.get(sessionId) || null;\r\n    }\r\n\r\n    if (!isSupabaseConfigured) {\r\n        return null;\r\n    }\r\n\r\n    try {\r\n        const { data, error } = await supabase\r\n            .from('live_sessions')\r\n            .select('*')\r\n            .eq('id', sessionId)\r\n            .eq('is_locked', true)\r\n            .maybeSingle();\r\n\r\n        if (error) {\r\n            console.error('Failed to fetch session:', error.message);\r\n            return null;\r\n        }\r\n\r\n        if (data) {\r\n            // Update cache\r\n            sessionsCache.set(sessionId, data);\r\n            console.log('ðŸ“‹ Restored session from Supabase:', machineName);\r\n        }\r\n\r\n        return data;\r\n    } catch (e) {\r\n        console.error('Failed to fetch session by machine:', e);\r\n        return null;\r\n    }\r\n};\r\n\r\n// ==========================================\r\n// GET ACTIVE SUB-MACHINES (Replacement for localStorage check)\r\n// ==========================================\r\nexport const getActiveSubMachinesFromSupabase = async (\r\n    parentMachineName: string,\r\n    subMachineCount: number\r\n): Promise<Set<number>> => {\r\n    const activeSet = new Set<number>();\r\n    const sessions = await fetchActiveSessions();\r\n\r\n    for (let i = 1; i <= subMachineCount; i++) {\r\n        const fullName = `${parentMachineName} - Machine ${i}`;\r\n        const isActive = sessions.some(s => s.machine_name === fullName && s.is_locked);\r\n        if (isActive) {\r\n            activeSet.add(i);\r\n        }\r\n    }\r\n\r\n    return activeSet;\r\n};\r\n\r\n// ==========================================\r\n// SUBSCRIBE TO SESSION CHANGES (Real-time)\r\n// ==========================================\r\nexport const subscribeToSessionChanges = (\r\n    onUpdate: (sessions: LiveSession[]) => void\r\n) => {\r\n    if (!isSupabaseConfigured) {\r\n        return () => { }; // No-op unsubscribe\r\n    }\r\n\r\n    const today = new Date().toISOString().split('T')[0];\r\n\r\n    const channel = supabase\r\n        .channel('live-sessions-changes')\r\n        .on(\r\n            'postgres_changes',\r\n            { event: '*', schema: 'public', table: 'live_sessions' },\r\n            async (payload) => {\r\n                console.log('ðŸ”„ Real-time session update received:', payload.eventType);\r\n                // Refetch all sessions on any change\r\n                const sessions = await fetchActiveSessions();\r\n                onUpdate(sessions);\r\n            }\r\n        )\r\n        .subscribe((status) => {\r\n            console.log('ðŸ“¡ Session subscription status:', status);\r\n        });\r\n\r\n    return () => {\r\n        supabase.removeChannel(channel);\r\n    };\r\n};\r\n\r\n// ==========================================\r\n// SYNC PENDING SESSIONS (On reconnection)\r\n// ==========================================\r\nexport const syncPendingSessions = async (): Promise<void> => {\r\n    if (!isSupabaseConfigured) return;\r\n\r\n    // Any sessions in cache that might not be synced yet\r\n    for (const session of Array.from(sessionsCache.values())) {\r\n        try {\r\n            await supabase\r\n                .from('live_sessions')\r\n                .upsert({\r\n                    id: session.id,\r\n                    machine_name: session.machine_name,\r\n                    operator_name: session.operator_name,\r\n                    order_number: session.order_number,\r\n                    product: session.product,\r\n                    batch_number: session.batch_number,\r\n                    shift: session.shift,\r\n                    session_date: session.session_date,\r\n                    is_locked: session.is_locked,\r\n                    updated_at: new Date().toISOString(),\r\n                }, { onConflict: 'id' });\r\n        } catch (e) {\r\n            console.error('Failed to sync session:', session.id, e);\r\n        }\r\n    }\r\n};\r\n","export interface WasteEntry {\r\n  id: string;\r\n  waste: number;\r\n  wasteType: string;\r\n  timestamp: Date;\r\n}\r\n\r\nexport interface DowntimeEntry {\r\n  id: string;\r\n  downtime: number;\r\n  downtimeReason: string;\r\n  notes?: string;\r\n  timestamp: Date;\r\n}\r\n\r\n// Production timer state for tracking run time and pauses\r\nexport interface ProductionState {\r\n  isRunning: boolean;\r\n  startTime: Date | null;       // When production started\r\n  pausedAt: Date | null;        // When current pause began\r\n  totalRunTimeMs: number;       // Accumulated run time in milliseconds\r\n  lastResumedAt: Date | null;   // When last resumed from pause\r\n}\r\n\r\nexport interface SpeedEntry {\r\n  id: string;\r\n  speed: number;\r\n  timestamp: Date;\r\n}\r\n\r\nexport interface SachetMassEntry {\r\n  id: string;\r\n  mass: number; // in grams\r\n  timestamp: Date;\r\n  ignored?: boolean; // Can be set to ignore but not deleted\r\n}\r\n\r\n// Loose cases entry - for cases not part of a full pallet\r\nexport interface LooseCasesEntry {\r\n  id: string;\r\n  batchNumber: string; // 5-digit batch number\r\n  cases: number; // number of loose cases\r\n  timestamp: Date;\r\n  ignored?: boolean;\r\n}\r\n\r\n// Pallet Scan entry - QR code is 13 digits: BBBBBPPPPCCCC\r\n// B = batch number (5 digits), P = pallet number (4 digits), C = cases count (4 digits)\r\nexport interface PalletScanEntry {\r\n  id: string;\r\n  qrCode: string; // Full 13-digit QR code\r\n  batchNumber: string; // Extracted: first 5 digits\r\n  palletNumber: string; // Extracted: digits 6-9 (4 digits)\r\n  casesCount: number; // Extracted: last 4 digits\r\n  timestamp: Date;\r\n  ignored?: boolean;\r\n}\r\n\r\n// Legacy CasesPerHourEntry - kept for backwards compatibility\r\nexport interface CasesPerHourEntry {\r\n  id: string;\r\n  cases: number;\r\n  hour: number;\r\n  timestamp: Date;\r\n  ignored?: boolean;\r\n}\r\n\r\nexport interface ShiftData {\r\n  id: string;\r\n  operatorName: string;\r\n  machine: string;\r\n  subMachine?: string; // For machines that are groups (e.g., \"Universal 2 - Machine 1\")\r\n  orderNumber: string;\r\n  product: string;\r\n  batchNumber: string;\r\n  shift: string;\r\n  date: string;\r\n  wasteEntries: WasteEntry[];\r\n  downtimeEntries: DowntimeEntry[];\r\n  speedEntries?: SpeedEntry[];\r\n  sachetMassEntries?: SachetMassEntry[];\r\n  casesPerHourEntries?: CasesPerHourEntry[]; // Legacy - kept for backwards compatibility\r\n  looseCasesEntries?: LooseCasesEntry[]; // New: loose cases with batch number\r\n  palletScanEntries?: PalletScanEntry[];\r\n  submittedAt: Date;\r\n  totalWaste: number;\r\n  totalDowntime: number;\r\n}\r\n\r\nexport interface ShiftSession {\r\n  machineName: string;\r\n  operatorName: string;\r\n  orderNumber: string;\r\n  product: string;\r\n  batchNumber: string;\r\n  shift: string;\r\n  date: string;\r\n  locked: boolean; // Once set, these values are locked for the shift\r\n  // Entry data persisted with session\r\n  wasteEntries?: WasteEntry[];\r\n  downtimeEntries?: DowntimeEntry[];\r\n  speedEntries?: SpeedEntry[];\r\n  sachetMassEntries?: SachetMassEntry[];\r\n  casesPerHourEntries?: CasesPerHourEntry[]; // Legacy\r\n  looseCasesEntries?: LooseCasesEntry[]; // New\r\n  palletScanEntries?: PalletScanEntry[];\r\n}\r\n\r\nexport interface Machine {\r\n  id: string;\r\n  name: string;\r\n  status: 'running' | 'idle' | 'maintenance';\r\n  currentOperator?: string;\r\n  currentOrder?: string;\r\n  currentShift?: string;\r\n  lastSubmission?: string;\r\n  todayWaste?: number;\r\n  todayDowntime?: number;\r\n  subMachineCount?: number; // Number of sub-machines (e.g., 4 for \"Universal 2\")\r\n}\r\n\r\n// ==============================================\r\n// DEFAULT DATA\r\n// ==============================================\r\n\r\nexport const OPERATORS: string[] = [];\r\nexport const MACHINES: Machine[] = [];\r\n\r\n// Waste Types - common manufacturing waste categories\r\nexport const WASTE_TYPES: string[] = [\r\n  'Start-up Waste',\r\n  'Changeover Waste',\r\n  'Defective Product',\r\n  'Material Spillage',\r\n];\r\n\r\n// Downtime Reasons - categorized by planned vs unplanned\r\nexport const PLANNED_DOWNTIME_REASONS: string[] = [\r\n  'Scheduled Maintenance',\r\n  'Changeover',\r\n];\r\n\r\nexport const UNPLANNED_DOWNTIME_REASONS: string[] = [\r\n  'Machine Breakdown',\r\n  'Material Shortage',\r\n];\r\n\r\n// Combined downtime reasons for selection\r\nexport const DOWNTIME_REASONS: string[] = [\r\n  'Machine Breakdown',\r\n  'Scheduled Maintenance',\r\n  'Changeover',\r\n  'Material Shortage',\r\n];\r\n\r\nexport const ORDER_NUMBERS: string[] = [];\r\nexport const PRODUCTS: string[] = [];\r\nexport const BATCH_NUMBERS: string[] = [];\r\n\r\n","import { ShiftData, Machine, MACHINES } from '../types';\r\nimport {\r\n  fetchMachines,\r\n  upsertMachine,\r\n  removeMachine,\r\n  syncMachinesToSupabase,\r\n  subscribeMachineChanges,\r\n  MachineRecord,\r\n  submitShiftData,\r\n  isSupabaseConfigured\r\n} from './supabase';\r\n\r\nconst STORAGE_KEY = 'waste_downtime_history';\r\nconst MACHINES_KEY = 'machines_data';\r\nconst MACHINES_SYNC_KEY = 'machines_last_sync';\r\nconst FAILED_SUBMISSIONS_KEY = 'failed_submissions_queue';\r\nconst HISTORY_MAX_DAYS = 90; // Keep history for 90 days\r\nconst HISTORY_MAX_ENTRIES = 1000; // Maximum entries to keep\r\n\r\n// ==========================================\r\n// FAILED SUBMISSIONS RETRY QUEUE\r\n// ==========================================\r\n\r\ninterface FailedSubmission {\r\n  id: string;\r\n  timestamp: string;\r\n  retryCount: number;\r\n  maxRetries: number;\r\n  data: {\r\n    shiftData: any;\r\n    wasteEntries: any[];\r\n    downtimeEntries: any[];\r\n    speedEntries?: any[];\r\n    sachetMassEntries?: any[];\r\n    looseCasesEntries?: any[];\r\n    palletScanEntries?: any[];\r\n  };\r\n  error: string;\r\n}\r\n\r\n// Get failed submissions queue\r\nexport const getFailedSubmissions = (): FailedSubmission[] => {\r\n  const stored = localStorage.getItem(FAILED_SUBMISSIONS_KEY);\r\n  if (!stored) return [];\r\n  try {\r\n    return JSON.parse(stored);\r\n  } catch {\r\n    return [];\r\n  }\r\n};\r\n\r\n// Add a failed submission to the retry queue\r\nexport const addFailedSubmission = (\r\n  data: FailedSubmission['data'],\r\n  error: string\r\n): void => {\r\n  const queue = getFailedSubmissions();\r\n  const newEntry: FailedSubmission = {\r\n    id: `failed_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\r\n    timestamp: new Date().toISOString(),\r\n    retryCount: 0,\r\n    maxRetries: 3,\r\n    data,\r\n    error,\r\n  };\r\n  queue.push(newEntry);\r\n  localStorage.setItem(FAILED_SUBMISSIONS_KEY, JSON.stringify(queue));\r\n};\r\n\r\n// Remove a submission from the failed queue\r\nexport const removeFailedSubmission = (id: string): void => {\r\n  const queue = getFailedSubmissions();\r\n  const filtered = queue.filter(s => s.id !== id);\r\n  localStorage.setItem(FAILED_SUBMISSIONS_KEY, JSON.stringify(filtered));\r\n};\r\n\r\n// Retry all failed submissions\r\nexport const retryFailedSubmissions = async (): Promise<{\r\n  succeeded: number;\r\n  failed: number;\r\n  remaining: number;\r\n}> => {\r\n  if (!isSupabaseConfigured) {\r\n    return { succeeded: 0, failed: 0, remaining: getFailedSubmissions().length };\r\n  }\r\n\r\n  const queue = getFailedSubmissions();\r\n  let succeeded = 0;\r\n  let failed = 0;\r\n\r\n  for (const submission of queue) {\r\n    if (submission.retryCount >= submission.maxRetries) {\r\n      // Max retries reached, keep in queue but don't retry\r\n      failed++;\r\n      continue;\r\n    }\r\n\r\n    try {\r\n      await submitShiftData(\r\n        submission.data.shiftData,\r\n        submission.data.wasteEntries,\r\n        submission.data.downtimeEntries,\r\n        submission.data.speedEntries,\r\n        submission.data.sachetMassEntries,\r\n        submission.data.looseCasesEntries,\r\n        submission.data.palletScanEntries\r\n      );\r\n      removeFailedSubmission(submission.id);\r\n      succeeded++;\r\n    } catch (e) {\r\n      // Update retry count\r\n      const updatedQueue = getFailedSubmissions().map(s =>\r\n        s.id === submission.id\r\n          ? { ...s, retryCount: s.retryCount + 1, error: String(e) }\r\n          : s\r\n      );\r\n      localStorage.setItem(FAILED_SUBMISSIONS_KEY, JSON.stringify(updatedQueue));\r\n      failed++;\r\n    }\r\n  }\r\n\r\n  return {\r\n    succeeded,\r\n    failed,\r\n    remaining: getFailedSubmissions().length,\r\n  };\r\n};\r\n\r\n// Clear all failed submissions (manual clear)\r\nexport const clearFailedSubmissions = (): void => {\r\n  localStorage.removeItem(FAILED_SUBMISSIONS_KEY);\r\n};\r\n\r\n// ==========================================\r\n// LOCALSTORAGE CLEANUP\r\n// ==========================================\r\n\r\n// Clean up old history entries\r\nexport const cleanupOldHistory = (): { removed: number; remaining: number } => {\r\n  const history = getShiftHistory();\r\n  const now = new Date();\r\n  const cutoffDate = new Date(now.getTime() - HISTORY_MAX_DAYS * 24 * 60 * 60 * 1000);\r\n\r\n  // Filter out entries older than cutoff date\r\n  let cleaned = history.filter(item => {\r\n    const itemDate = new Date(item.date);\r\n    return itemDate >= cutoffDate;\r\n  });\r\n\r\n  // Also limit to max entries (keep most recent)\r\n  if (cleaned.length > HISTORY_MAX_ENTRIES) {\r\n    cleaned = cleaned.slice(0, HISTORY_MAX_ENTRIES);\r\n  }\r\n\r\n  const removed = history.length - cleaned.length;\r\n\r\n  if (removed > 0) {\r\n    localStorage.setItem(STORAGE_KEY, JSON.stringify(cleaned));\r\n    console.log(`Cleaned up ${removed} old history entries`);\r\n  }\r\n\r\n  return { removed, remaining: cleaned.length };\r\n};\r\n\r\n// Get localStorage usage stats\r\nexport const getStorageStats = (): {\r\n  historyCount: number;\r\n  failedCount: number;\r\n  totalSizeKB: number;\r\n  oldestEntry: string | null;\r\n} => {\r\n  const history = getShiftHistory();\r\n  const failed = getFailedSubmissions();\r\n\r\n  // Estimate total localStorage size\r\n  let totalSize = 0;\r\n  for (let i = 0; i < localStorage.length; i++) {\r\n    const key = localStorage.key(i);\r\n    if (key) {\r\n      const value = localStorage.getItem(key) || '';\r\n      totalSize += key.length + value.length;\r\n    }\r\n  }\r\n\r\n  const oldestEntry = history.length > 0\r\n    ? history[history.length - 1].date\r\n    : null;\r\n\r\n  return {\r\n    historyCount: history.length,\r\n    failedCount: failed.length,\r\n    totalSizeKB: Math.round(totalSize / 1024),\r\n    oldestEntry,\r\n  };\r\n};\r\n\r\n// Run cleanup on app startup (debounced to run once per day)\r\nexport const maybeRunCleanup = (): void => {\r\n  const lastCleanupKey = 'last_storage_cleanup';\r\n  const lastCleanup = localStorage.getItem(lastCleanupKey);\r\n  const now = new Date();\r\n\r\n  if (lastCleanup) {\r\n    const lastDate = new Date(lastCleanup);\r\n    const hoursSinceCleanup = (now.getTime() - lastDate.getTime()) / (1000 * 60 * 60);\r\n    if (hoursSinceCleanup < 24) {\r\n      return; // Already cleaned up today\r\n    }\r\n  }\r\n\r\n  // Run cleanup\r\n  const result = cleanupOldHistory();\r\n  localStorage.setItem(lastCleanupKey, now.toISOString());\r\n\r\n  if (result.removed > 0) {\r\n    console.log(`Storage cleanup: removed ${result.removed} entries, ${result.remaining} remaining`);\r\n  }\r\n};\r\n\r\n// Flag to track if we're using Supabase\r\nlet useSupabase = true;\r\nlet machinesCache: Machine[] | null = null;\r\nlet machinesListeners: ((machines: Machine[]) => void)[] = [];\r\n\r\n// Convert Supabase record to local Machine type\r\nconst toLocalMachine = (record: MachineRecord): Machine => ({\r\n  id: record.id,\r\n  name: record.name,\r\n  status: record.status,\r\n  currentOperator: record.current_operator,\r\n  currentOrder: record.current_order,\r\n  currentShift: record.current_shift,\r\n  lastSubmission: record.last_submission,\r\n  todayWaste: record.today_waste,\r\n  todayDowntime: record.today_downtime,\r\n  subMachineCount: record.sub_machine_count,\r\n});\r\n\r\n// Convert local Machine to Supabase record\r\nconst toSupabaseRecord = (machine: Machine): MachineRecord => ({\r\n  id: machine.id,\r\n  name: machine.name,\r\n  status: machine.status,\r\n  current_operator: machine.currentOperator,\r\n  current_order: machine.currentOrder,\r\n  current_shift: machine.currentShift,\r\n  last_submission: machine.lastSubmission,\r\n  today_waste: machine.todayWaste,\r\n  today_downtime: machine.todayDowntime,\r\n  sub_machine_count: machine.subMachineCount,\r\n});\r\n\r\n// Initialize machines from Supabase\r\nexport const initializeMachines = async (): Promise<Machine[]> => {\r\n  try {\r\n    const records = await fetchMachines();\r\n\r\n    if (records.length > 0) {\r\n      machinesCache = records.map(toLocalMachine);\r\n      // Also save to localStorage as backup\r\n      localStorage.setItem(MACHINES_KEY, JSON.stringify(machinesCache));\r\n      localStorage.setItem(MACHINES_SYNC_KEY, new Date().toISOString());\r\n      return machinesCache;\r\n    } else {\r\n      // No machines in Supabase, sync default machines\r\n      console.log('No machines in Supabase, syncing defaults...');\r\n      const defaultMachines = MACHINES.map(toSupabaseRecord);\r\n      await syncMachinesToSupabase(defaultMachines);\r\n      machinesCache = MACHINES;\r\n      localStorage.setItem(MACHINES_KEY, JSON.stringify(MACHINES));\r\n      return MACHINES;\r\n    }\r\n  } catch (error) {\r\n    console.error('Failed to initialize from Supabase, using localStorage:', error);\r\n    useSupabase = false;\r\n    return getMachinesDataLocal();\r\n  }\r\n};\r\n\r\n// Subscribe to real-time machine updates - OPTIMIZED\r\nexport const subscribeToMachineUpdates = (callback: (machines: Machine[]) => void) => {\r\n  machinesListeners.push(callback);\r\n\r\n  // Provide current machines getter for optimized real-time updates\r\n  const getCurrentMachines = (): MachineRecord[] => {\r\n    const current = machinesCache || getMachinesDataLocal();\r\n    return current.map(toSupabaseRecord);\r\n  };\r\n\r\n  // Set up Supabase real-time subscription with optimized handler\r\n  const unsubscribe = subscribeMachineChanges(\r\n    (records) => {\r\n      machinesCache = records.map(toLocalMachine);\r\n      localStorage.setItem(MACHINES_KEY, JSON.stringify(machinesCache));\r\n\r\n      // Notify all listeners\r\n      machinesListeners.forEach(listener => listener(machinesCache!));\r\n    },\r\n    getCurrentMachines\r\n  );\r\n\r\n  // Return cleanup function\r\n  return () => {\r\n    machinesListeners = machinesListeners.filter(l => l !== callback);\r\n    if (machinesListeners.length === 0) {\r\n      unsubscribe();\r\n    }\r\n  };\r\n};\r\n\r\n// Get machines from localStorage (fallback)\r\nconst getMachinesDataLocal = (): Machine[] => {\r\n  const stored = localStorage.getItem(MACHINES_KEY);\r\n  if (!stored) {\r\n    localStorage.setItem(MACHINES_KEY, JSON.stringify(MACHINES));\r\n    return MACHINES;\r\n  }\r\n\r\n  try {\r\n    return JSON.parse(stored);\r\n  } catch {\r\n    return MACHINES;\r\n  }\r\n};\r\n\r\n// Save shift data to local storage\r\nexport const saveShiftData = (data: ShiftData): void => {\r\n  const existing = getShiftHistory();\r\n  existing.unshift(data);\r\n  localStorage.setItem(STORAGE_KEY, JSON.stringify(existing));\r\n\r\n  // Update machine data\r\n  updateMachineLastSubmission(data.machine, data.submittedAt.toISOString());\r\n};\r\n\r\n// Get all shift history\r\nexport const getShiftHistory = (): ShiftData[] => {\r\n  const stored = localStorage.getItem(STORAGE_KEY);\r\n  if (!stored) return [];\r\n\r\n  try {\r\n    const parsed = JSON.parse(stored);\r\n    return parsed.map((item: any) => ({\r\n      ...item,\r\n      submittedAt: new Date(item.submittedAt),\r\n      wasteEntries: item.wasteEntries.map((w: any) => ({\r\n        ...w,\r\n        timestamp: new Date(w.timestamp),\r\n      })),\r\n      downtimeEntries: item.downtimeEntries.map((d: any) => ({\r\n        ...d,\r\n        timestamp: new Date(d.timestamp),\r\n      })),\r\n    }));\r\n  } catch {\r\n    return [];\r\n  }\r\n};\r\n\r\n// Get shift history for a specific date range\r\nexport const getShiftHistoryByDateRange = (startDate: Date, endDate: Date): ShiftData[] => {\r\n  const history = getShiftHistory();\r\n  return history.filter(item => {\r\n    const itemDate = new Date(item.date);\r\n    return itemDate >= startDate && itemDate <= endDate;\r\n  });\r\n};\r\n\r\n// Get shift history for a specific machine\r\nexport const getShiftHistoryByMachine = (machineName: string): ShiftData[] => {\r\n  const history = getShiftHistory();\r\n  return history.filter(item => item.machine === machineName);\r\n};\r\n\r\n// Get today's statistics\r\nexport const getTodayStats = () => {\r\n  const today = new Date().toISOString().split('T')[0];\r\n  const history = getShiftHistory();\r\n  const todayData = history.filter(item => item.date === today);\r\n\r\n  const totalWaste = todayData.reduce((sum, item) => sum + item.totalWaste, 0);\r\n  const totalDowntime = todayData.reduce((sum, item) => sum + item.totalDowntime, 0);\r\n  const submissionCount = todayData.length;\r\n\r\n  return { totalWaste, totalDowntime, submissionCount };\r\n};\r\n\r\n// Update machine last submission\r\nexport const updateMachineLastSubmission = (machineName: string, timestamp: string): void => {\r\n  const machines = getMachinesData();\r\n  const machineIndex = machines.findIndex(m => m.name === machineName);\r\n  if (machineIndex !== -1) {\r\n    machines[machineIndex].lastSubmission = getTimeAgo(new Date(timestamp));\r\n  }\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(machines));\r\n};\r\n\r\n// Get machines data with local modifications\r\nexport const getMachinesData = (): Machine[] => {\r\n  // Return cache if available\r\n  if (machinesCache) {\r\n    return machinesCache;\r\n  }\r\n\r\n  // Otherwise return from localStorage\r\n  return getMachinesDataLocal();\r\n};\r\n\r\n// Update a single machine\r\nexport const updateMachine = async (machineId: string, updates: Partial<Machine>): Promise<void> => {\r\n  const machines = getMachinesData();\r\n  const index = machines.findIndex(m => m.id === machineId);\r\n  if (index !== -1) {\r\n    machines[index] = { ...machines[index], ...updates };\r\n    machinesCache = machines;\r\n    localStorage.setItem(MACHINES_KEY, JSON.stringify(machines));\r\n\r\n    // Sync to Supabase\r\n    if (useSupabase) {\r\n      try {\r\n        await upsertMachine(toSupabaseRecord(machines[index]));\r\n      } catch (error) {\r\n        console.error('Failed to sync machine update to Supabase:', error);\r\n      }\r\n    }\r\n  }\r\n};\r\n\r\n// Add a new machine\r\nexport const addMachine = async (machine: Machine): Promise<void> => {\r\n  const machines = getMachinesData();\r\n  machines.push(machine);\r\n  machinesCache = machines;\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(machines));\r\n\r\n  // Sync to Supabase\r\n  if (useSupabase) {\r\n    try {\r\n      await upsertMachine(toSupabaseRecord(machine));\r\n    } catch (error) {\r\n      console.error('Failed to sync new machine to Supabase:', error);\r\n    }\r\n  }\r\n};\r\n\r\n// Delete a machine\r\nexport const deleteMachine = async (machineId: string): Promise<void> => {\r\n  const machines = getMachinesData();\r\n  const filtered = machines.filter(m => m.id !== machineId);\r\n  machinesCache = filtered;\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(filtered));\r\n\r\n  // Sync to Supabase\r\n  if (useSupabase) {\r\n    try {\r\n      await removeMachine(machineId);\r\n    } catch (error) {\r\n      console.error('Failed to delete machine from Supabase:', error);\r\n    }\r\n  }\r\n};\r\n\r\n// Reset machines to default\r\nexport const resetMachines = async (): Promise<void> => {\r\n  machinesCache = MACHINES;\r\n  localStorage.setItem(MACHINES_KEY, JSON.stringify(MACHINES));\r\n\r\n  // Sync to Supabase\r\n  if (useSupabase) {\r\n    try {\r\n      await syncMachinesToSupabase(MACHINES.map(toSupabaseRecord));\r\n    } catch (error) {\r\n      console.error('Failed to reset machines in Supabase:', error);\r\n    }\r\n  }\r\n};\r\n\r\n// Helper function to format time ago\r\nexport const getTimeAgo = (date: Date): string => {\r\n  const now = new Date();\r\n  const diffMs = now.getTime() - date.getTime();\r\n  const diffMins = Math.floor(diffMs / 60000);\r\n  const diffHours = Math.floor(diffMins / 60);\r\n  const diffDays = Math.floor(diffHours / 24);\r\n\r\n  if (diffMins < 1) return 'Just now';\r\n  if (diffMins < 60) return `${diffMins} min ago`;\r\n  if (diffHours < 24) return `${diffHours} hour${diffHours > 1 ? 's' : ''} ago`;\r\n  return `${diffDays} day${diffDays > 1 ? 's' : ''} ago`;\r\n};\r\n\r\n// Export data to CSV\r\nexport const exportToCSV = (data: ShiftData[], filename: string): void => {\r\n  const headers = [\r\n    'Date',\r\n    'Shift',\r\n    'Operator',\r\n    'Machine',\r\n    'Order Number',\r\n    'Product',\r\n    'Batch Number',\r\n    'Entry Type',\r\n    'Waste Type',\r\n    'Waste (kg)',\r\n    'Downtime Reason',\r\n    'Downtime (min)',\r\n    'Submitted At',\r\n  ];\r\n\r\n  const rows: string[][] = [];\r\n\r\n  data.forEach(item => {\r\n    const baseRow = [\r\n      item.date,\r\n      item.shift,\r\n      item.operatorName,\r\n      item.machine,\r\n      item.orderNumber,\r\n      item.product,\r\n      item.batchNumber,\r\n    ];\r\n    const submittedAt = new Date(item.submittedAt).toLocaleString();\r\n\r\n    // Add a row for each waste entry\r\n    if (item.wasteEntries && item.wasteEntries.length > 0) {\r\n      item.wasteEntries.forEach(w => {\r\n        rows.push([\r\n          ...baseRow,\r\n          'Waste',\r\n          w.wasteType,\r\n          w.waste.toFixed(2),\r\n          '',\r\n          '',\r\n          submittedAt,\r\n        ]);\r\n      });\r\n    }\r\n\r\n    // Add a row for each downtime entry\r\n    if (item.downtimeEntries && item.downtimeEntries.length > 0) {\r\n      item.downtimeEntries.forEach(d => {\r\n        rows.push([\r\n          ...baseRow,\r\n          'Downtime',\r\n          '',\r\n          '',\r\n          d.downtimeReason,\r\n          d.downtime.toString(),\r\n          submittedAt,\r\n        ]);\r\n      });\r\n    }\r\n\r\n    // If no entries at all, still add one summary row\r\n    if ((!item.wasteEntries || item.wasteEntries.length === 0) &&\r\n      (!item.downtimeEntries || item.downtimeEntries.length === 0)) {\r\n      rows.push([\r\n        ...baseRow,\r\n        'Summary',\r\n        '',\r\n        item.totalWaste.toFixed(2),\r\n        '',\r\n        item.totalDowntime.toString(),\r\n        submittedAt,\r\n      ]);\r\n    }\r\n  });\r\n\r\n  const csvContent = [\r\n    headers.join(','),\r\n    ...rows.map(row => row.map(cell => `\"${cell}\"`).join(',')),\r\n  ].join('\\n');\r\n\r\n  const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });\r\n  const link = document.createElement('a');\r\n  const url = URL.createObjectURL(blob);\r\n  link.setAttribute('href', url);\r\n  link.setAttribute('download', `${filename}.csv`);\r\n  link.style.visibility = 'hidden';\r\n  document.body.appendChild(link);\r\n  link.click();\r\n  document.body.removeChild(link);\r\n  // Clean up the object URL to prevent memory leak\r\n  URL.revokeObjectURL(url);\r\n};\r\n\r\n// Clear all history (for testing)\r\nexport const clearHistory = (): void => {\r\n  localStorage.removeItem(STORAGE_KEY);\r\n  localStorage.removeItem(MACHINES_KEY);\r\n};\r\n\r\n// ==========================================\r\n// SHARED LINE SPEED - Syncs across sub-machines\r\n// ==========================================\r\n\r\nconst LINE_SPEED_KEY_PREFIX = 'line_speed_';\r\n\r\n/**\r\n * Extract parent machine name from a sub-machine name\r\n * e.g., \"Cubes - Machine 1\" â†’ \"Cubes\"\r\n * e.g., \"Universal 2 - Machine 3\" â†’ \"Universal 2\"\r\n */\r\nexport const getParentMachineName = (machineName: string): string => {\r\n  // Check if it matches the pattern \"Parent - Machine N\"\r\n  const match = machineName.match(/^(.+?)\\s*-\\s*Machine\\s*\\d+$/i);\r\n  if (match) {\r\n    return match[1].trim();\r\n  }\r\n  // Return the original name if no sub-machine pattern found\r\n  return machineName;\r\n};\r\n\r\n/**\r\n * Get the storage key for shared line speed\r\n */\r\nconst getLineSpeedKey = (parentMachineName: string, shift: string, date: string): string => {\r\n  return `${LINE_SPEED_KEY_PREFIX}${parentMachineName}_${shift}_${date}`;\r\n};\r\n\r\n/**\r\n * Save shared line speed (called when any sub-machine sets speed)\r\n */\r\nexport const saveLineSpeed = (\r\n  machineName: string,\r\n  shift: string,\r\n  date: string,\r\n  speed: number\r\n): void => {\r\n  const parentName = getParentMachineName(machineName);\r\n  const key = getLineSpeedKey(parentName, shift, date);\r\n\r\n  const data = {\r\n    speed,\r\n    updatedAt: new Date().toISOString(),\r\n    updatedBy: machineName,\r\n  };\r\n\r\n  localStorage.setItem(key, JSON.stringify(data));\r\n  console.log(`ðŸ’¾ Saved line speed ${speed} PPM for ${parentName}`);\r\n};\r\n\r\n/**\r\n * Get shared line speed (returns the speed set by any sibling machine)\r\n */\r\nexport const getLineSpeed = (\r\n  machineName: string,\r\n  shift: string,\r\n  date: string\r\n): { speed: number; updatedBy: string; updatedAt: string } | null => {\r\n  const parentName = getParentMachineName(machineName);\r\n  const key = getLineSpeedKey(parentName, shift, date);\r\n\r\n  const stored = localStorage.getItem(key);\r\n  if (!stored) return null;\r\n\r\n  try {\r\n    const data = JSON.parse(stored);\r\n    console.log(`ðŸ“– Loaded line speed ${data.speed} PPM for ${parentName} (set by ${data.updatedBy})`);\r\n    return data;\r\n  } catch {\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Clear shared line speed (called when session ends)\r\n */\r\nexport const clearLineSpeed = (\r\n  machineName: string,\r\n  shift: string,\r\n  date: string\r\n): void => {\r\n  const parentName = getParentMachineName(machineName);\r\n  const key = getLineSpeedKey(parentName, shift, date);\r\n  localStorage.removeItem(key);\r\n};\r\n\r\n/**\r\n * Clean up old line speed entries (called periodically)\r\n */\r\nexport const cleanupOldLineSpeeds = (retentionDays: number = 7): number => {\r\n  const cutoff = Date.now() - (retentionDays * 24 * 60 * 60 * 1000);\r\n  let removed = 0;\r\n\r\n  for (let i = localStorage.length - 1; i >= 0; i--) {\r\n    const key = localStorage.key(i);\r\n    if (key?.startsWith(LINE_SPEED_KEY_PREFIX)) {\r\n      try {\r\n        const data = localStorage.getItem(key);\r\n        if (data) {\r\n          const parsed = JSON.parse(data);\r\n          const updatedAt = new Date(parsed.updatedAt).getTime();\r\n          if (updatedAt < cutoff) {\r\n            localStorage.removeItem(key);\r\n            removed++;\r\n          }\r\n        }\r\n      } catch {\r\n        // Invalid data - remove it\r\n        localStorage.removeItem(key);\r\n        removed++;\r\n      }\r\n    }\r\n  }\r\n\r\n  return removed;\r\n};\r\n"],"names":["getLiveSessionId","machineName","shift","date","concat","sessionsCache","Map","lastFetchTime","upsertLiveSession","async","sessionId","session","liveSession","id","machine_name","operator_name","operatorName","order_number","orderNumber","product","batch_number","batchNumber","session_date","is_locked","locked","total_waste","totalWaste","total_downtime","totalDowntime","updated_at","Date","toISOString","set","isSupabaseConfigured","error","supabase","from","upsert","onConflict","console","message","log","e","deleteLiveSession","delete","eq","fetchActiveSessions","now","today","split","shouldUseCache","data","select","Array","values","filter","s","clear","forEach","length","map","fetchLiveSessionByMachine","has","get","maybeSingle","subscribeToSessionChanges","onUpdate","channel","on","event","schema","table","payload","eventType","sessions","subscribe","status","removeChannel","MACHINES","WASTE_TYPES","DOWNTIME_REASONS","STORAGE_KEY","MACHINES_KEY","FAILED_SUBMISSIONS_KEY","getFailedSubmissions","stored","localStorage","getItem","JSON","parse","_unused","addFailedSubmission","queue","newEntry","Math","random","toString","substr","timestamp","retryCount","maxRetries","push","setItem","stringify","removeFailedSubmission","filtered","retryFailedSubmissions","succeeded","failed","remaining","submission","submitShiftData","shiftData","wasteEntries","downtimeEntries","speedEntries","sachetMassEntries","looseCasesEntries","palletScanEntries","updatedQueue","_objectSpread","String","maybeRunCleanup","lastCleanupKey","lastCleanup","lastDate","getTime","result","cleanupOldHistory","history","getShiftHistory","cutoffDate","HISTORY_MAX_DAYS","cleaned","item","slice","removed","useSupabase","machinesCache","machinesListeners","toLocalMachine","record","name","currentOperator","current_operator","currentOrder","current_order","currentShift","current_shift","lastSubmission","last_submission","todayWaste","today_waste","todayDowntime","today_downtime","subMachineCount","sub_machine_count","toSupabaseRecord","machine","initializeMachines","records","fetchMachines","defaultMachines","syncMachinesToSupabase","getMachinesDataLocal","subscribeToMachineUpdates","callback","unsubscribe","subscribeMachineChanges","listener","getCurrentMachines","l","_unused2","saveShiftData","existing","unshift","updateMachineLastSubmission","submittedAt","w","d","_unused3","getTodayStats","todayData","reduce","sum","submissionCount","machines","getMachinesData","machineIndex","findIndex","m","getTimeAgo","updateMachine","machineId","updates","index","upsertMachine","addMachine","deleteMachine","removeMachine","diffMs","diffMins","floor","diffHours","diffDays","exportToCSV","filename","rows","baseRow","toLocaleString","wasteType","waste","toFixed","downtimeReason","downtime","csvContent","join","row","cell","blob","Blob","type","link","document","createElement","url","URL","createObjectURL","setAttribute","style","visibility","body","appendChild","click","removeChild","revokeObjectURL","LINE_SPEED_KEY_PREFIX","getParentMachineName","match","trim","getLineSpeedKey","parentMachineName","saveLineSpeed","speed","parentName","key","updatedAt","updatedBy","getLineSpeed","_unused4"],"ignoreList":[],"sourceRoot":""}